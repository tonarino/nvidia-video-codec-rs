/* automatically generated by rust-bindgen */

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type std_size_t = ::std::os::raw::c_ulong;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = std_size_t;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = std_size_t;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type CUdeviceptr = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[doc = "< Host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_HOST: CUmemorytype_enum = 1;
#[doc = "< Device memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_DEVICE: CUmemorytype_enum = 2;
#[doc = "< Array memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_ARRAY: CUmemorytype_enum = 3;
#[doc = "< Unified device or host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_UNIFIED: CUmemorytype_enum = 4;
#[doc = " Memory types"]
pub type CUmemorytype_enum = u32;
#[doc = " Memory types"]
pub use self::CUmemorytype_enum as CUmemorytype;
#[doc = " \\struct GUID"]
#[doc = " Abstracts the GUID structure for non-windows platforms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GUID {
    #[doc = "< [in]: Specifies the first 8 hexadecimal digits of the GUID."]
    pub Data1: u32,
    #[doc = "< [in]: Specifies the first group of 4 hexadecimal digits."]
    pub Data2: u16,
    #[doc = "< [in]: Specifies the second group of 4 hexadecimal digits."]
    pub Data3: u16,
    #[doc = "< [in]: Array of 8 bytes. The first 2 bytes contain the third group of 4 hexadecimal digits."]
    #[doc = "The remaining 6 bytes contain the final 12 hexadecimal digits."]
    pub Data4: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_GUID() {
    assert_eq!(
        ::std::mem::size_of::<GUID>(),
        16usize,
        concat!("Size of: ", stringify!(GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(GUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GUID>())).Data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GUID),
            "::",
            stringify!(Data4)
        )
    );
}
#[doc = " @}"]
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::std::os::raw::c_void;
#[doc = "< Frame mode"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 1;
#[doc = "< Field mode"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 2;
#[doc = "< MB adaptive frame/field"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 3;
#[doc = " Input frame encode modes"]
pub type _NV_ENC_PARAMS_FRAME_FIELD_MODE = u32;
#[doc = " Input frame encode modes"]
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
#[doc = "< Constant QP mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CONSTQP: _NV_ENC_PARAMS_RC_MODE = 0;
#[doc = "< Variable bitrate mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_VBR: _NV_ENC_PARAMS_RC_MODE = 1;
#[doc = "< Constant bitrate mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR: _NV_ENC_PARAMS_RC_MODE = 2;
#[doc = "< low-delay CBR, high quality"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ: _NV_ENC_PARAMS_RC_MODE = 8;
#[doc = "< CBR, high quality (slower)"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR_HQ: _NV_ENC_PARAMS_RC_MODE = 16;
#[doc = "< VBR, high quality (slower)"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_VBR_HQ: _NV_ENC_PARAMS_RC_MODE = 32;
#[doc = " Rate Control Modes"]
pub type _NV_ENC_PARAMS_RC_MODE = u32;
#[doc = " Rate Control Modes"]
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap have no effect."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_DISABLED: _NV_ENC_QP_MAP_MODE = 0;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as Empasis level. Currently this is only supported for H264"]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_EMPHASIS: _NV_ENC_QP_MAP_MODE = 1;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP delta map."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_DELTA: _NV_ENC_QP_MAP_MODE = 2;
#[doc = "< Currently This is not supported. Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP value."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP: _NV_ENC_QP_MAP_MODE = 3;
#[doc = " QP MAP MODE"]
pub type _NV_ENC_QP_MAP_MODE = u32;
#[doc = " QP MAP MODE"]
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
#[doc = "< Progressive frame"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FRAME: _NV_ENC_PIC_STRUCT = 1;
#[doc = "< Field encoding top field first"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM: _NV_ENC_PIC_STRUCT = 2;
#[doc = "< Field encoding bottom field first"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP: _NV_ENC_PIC_STRUCT = 3;
#[doc = " Input picture structure"]
pub type _NV_ENC_PIC_STRUCT = u32;
#[doc = " Input picture structure"]
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
#[doc = "< Forward predicted"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_P: _NV_ENC_PIC_TYPE = 0;
#[doc = "< Bi-directionally predicted picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_B: _NV_ENC_PIC_TYPE = 1;
#[doc = "< Intra predicted picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_I: _NV_ENC_PIC_TYPE = 2;
#[doc = "< IDR picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_IDR: _NV_ENC_PIC_TYPE = 3;
#[doc = "< Bi-directionally predicted with only Intra MBs"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_BI: _NV_ENC_PIC_TYPE = 4;
#[doc = "< Picture is skipped"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_SKIPPED: _NV_ENC_PIC_TYPE = 5;
#[doc = "< First picture in intra refresh cycle"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_INTRA_REFRESH: _NV_ENC_PIC_TYPE = 6;
#[doc = "< Non reference P picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_NONREF_P: _NV_ENC_PIC_TYPE = 7;
#[doc = "< Picture type unknown"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_UNKNOWN: _NV_ENC_PIC_TYPE = 255;
#[doc = " Input picture type"]
pub type _NV_ENC_PIC_TYPE = u32;
#[doc = " Input picture type"]
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
#[doc = "<Driver selects QuarterPel motion vector precision by default"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_DEFAULT: _NV_ENC_MV_PRECISION = 0;
#[doc = "< FullPel  motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_FULL_PEL: _NV_ENC_MV_PRECISION = 1;
#[doc = "< HalfPel motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_HALF_PEL: _NV_ENC_MV_PRECISION = 2;
#[doc = "< QuarterPel motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_QUARTER_PEL: _NV_ENC_MV_PRECISION = 3;
#[doc = " Motion vector precisions"]
pub type _NV_ENC_MV_PRECISION = u32;
#[doc = " Motion vector precisions"]
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
#[doc = "< Undefined buffer format"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_UNDEFINED: _NV_ENC_BUFFER_FORMAT = 0;
#[doc = "< Semi-Planar YUV [Y plane followed by interleaved UV plane]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_NV12: _NV_ENC_BUFFER_FORMAT = 1;
#[doc = "< Planar YUV [Y plane followed by V and U planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YV12: _NV_ENC_BUFFER_FORMAT = 16;
#[doc = "< Planar YUV [Y plane followed by U and V planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_IYUV: _NV_ENC_BUFFER_FORMAT = 256;
#[doc = "< Planar YUV [Y plane followed by U and V planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV444: _NV_ENC_BUFFER_FORMAT = 4096;
#[doc = "< 10 bit Semi-Planar YUV [Y plane followed by interleaved UV plane]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV420_10BIT: _NV_ENC_BUFFER_FORMAT = 65536;
#[doc = "< 10 bit Planar YUV444 [Y plane followed by U and V planes]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV444_10BIT: _NV_ENC_BUFFER_FORMAT = 1048576;
#[doc = "< 8 bit Packed A8R8G8B8. This is a word-ordered format"]
#[doc = "where a pixel is represented by a 32-bit word with B"]
#[doc = "in the lowest 8 bits, G in the next 8 bits, R in the"]
#[doc = "8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ARGB: _NV_ENC_BUFFER_FORMAT = 16777216;
#[doc = "< 10 bit Packed A2R10G10B10. This is a word-ordered format"]
#[doc = "where a pixel is represented by a 32-bit word with B"]
#[doc = "in the lowest 10 bits, G in the next 10 bits, R in the"]
#[doc = "10 bits after that and A in the highest 2 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ARGB10: _NV_ENC_BUFFER_FORMAT = 33554432;
#[doc = "< 8 bit Packed A8Y8U8V8. This is a word-ordered format"]
#[doc = "where a pixel is represented by a 32-bit word with V"]
#[doc = "in the lowest 8 bits, U in the next 8 bits, Y in the"]
#[doc = "8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_AYUV: _NV_ENC_BUFFER_FORMAT = 67108864;
#[doc = "< 8 bit Packed A8B8G8R8. This is a word-ordered format"]
#[doc = "where a pixel is represented by a 32-bit word with R"]
#[doc = "in the lowest 8 bits, G in the next 8 bits, B in the"]
#[doc = "8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ABGR: _NV_ENC_BUFFER_FORMAT = 268435456;
#[doc = "< 10 bit Packed A2B10G10R10. This is a word-ordered format"]
#[doc = "where a pixel is represented by a 32-bit word with R"]
#[doc = "in the lowest 10 bits, G in the next 10 bits, B in the"]
#[doc = "10 bits after that and A in the highest 2 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ABGR10: _NV_ENC_BUFFER_FORMAT = 536870912;
#[doc = "< Buffer format representing one-dimensional buffer."]
#[doc = "This format should be used only when registering the"]
#[doc = "resource as output buffer, which will be used to write"]
#[doc = "the encoded bit stream or H.264 ME only mode output."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_U8: _NV_ENC_BUFFER_FORMAT = 1073741824;
#[doc = " Input buffer formats"]
pub type _NV_ENC_BUFFER_FORMAT = u32;
#[doc = " Input buffer formats"]
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
#[doc = " This indicates that API call returned with no errors."]
pub const _NVENCSTATUS_NV_ENC_SUCCESS: _NVENCSTATUS = 0;
#[doc = " This indicates that no encode capable devices were detected."]
pub const _NVENCSTATUS_NV_ENC_ERR_NO_ENCODE_DEVICE: _NVENCSTATUS = 1;
#[doc = " This indicates that devices pass by the client is not supported."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNSUPPORTED_DEVICE: _NVENCSTATUS = 2;
#[doc = " This indicates that the encoder device supplied by the client is not"]
#[doc = " valid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_ENCODERDEVICE: _NVENCSTATUS = 3;
#[doc = " This indicates that device passed to the API call is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_DEVICE: _NVENCSTATUS = 4;
#[doc = " This indicates that device passed to the API call is no longer available and"]
#[doc = " needs to be reinitialized. The clients need to destroy the current encoder"]
#[doc = " session by freeing the allocated input output buffers and destroying the device"]
#[doc = " and create a new encoding session."]
pub const _NVENCSTATUS_NV_ENC_ERR_DEVICE_NOT_EXIST: _NVENCSTATUS = 5;
#[doc = " This indicates that one or more of the pointers passed to the API call"]
#[doc = " is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_PTR: _NVENCSTATUS = 6;
#[doc = " This indicates that completion event passed in ::NvEncEncodePicture() call"]
#[doc = " is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_EVENT: _NVENCSTATUS = 7;
#[doc = " This indicates that one or more of the parameter passed to the API call"]
#[doc = " is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_PARAM: _NVENCSTATUS = 8;
#[doc = " This indicates that an API call was made in wrong sequence/order."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_CALL: _NVENCSTATUS = 9;
#[doc = " This indicates that the API call failed because it was unable to allocate"]
#[doc = " enough memory to perform the requested operation."]
pub const _NVENCSTATUS_NV_ENC_ERR_OUT_OF_MEMORY: _NVENCSTATUS = 10;
#[doc = " This indicates that the encoder has not been initialized with"]
#[doc = " ::NvEncInitializeEncoder() or that initialization has failed."]
#[doc = " The client cannot allocate input or output buffers or do any encoding"]
#[doc = " related operation before successfully initializing the encoder."]
pub const _NVENCSTATUS_NV_ENC_ERR_ENCODER_NOT_INITIALIZED: _NVENCSTATUS = 11;
#[doc = " This indicates that an unsupported parameter was passed by the client."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNSUPPORTED_PARAM: _NVENCSTATUS = 12;
#[doc = " This indicates that the ::NvEncLockBitstream() failed to lock the output"]
#[doc = " buffer. This happens when the client makes a non blocking lock call to"]
#[doc = " access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag."]
#[doc = " This is not a fatal error and client should retry the same operation after"]
#[doc = " few milliseconds."]
pub const _NVENCSTATUS_NV_ENC_ERR_LOCK_BUSY: _NVENCSTATUS = 13;
#[doc = " This indicates that the size of the user buffer passed by the client is"]
#[doc = " insufficient for the requested operation."]
pub const _NVENCSTATUS_NV_ENC_ERR_NOT_ENOUGH_BUFFER: _NVENCSTATUS = 14;
#[doc = " This indicates that an invalid struct version was used by the client."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_VERSION: _NVENCSTATUS = 15;
#[doc = " This indicates that ::NvEncMapInputResource() API failed to map the client"]
#[doc = " provided input resource."]
pub const _NVENCSTATUS_NV_ENC_ERR_MAP_FAILED: _NVENCSTATUS = 16;
#[doc = " This indicates encode driver requires more input buffers to produce an output"]
#[doc = " bitstream. If this error is returned from ::NvEncEncodePicture() API, this"]
#[doc = " is not a fatal error. If the client is encoding with B frames then,"]
#[doc = " ::NvEncEncodePicture() API might be buffering the input frame for re-ordering."]
#[doc = ""]
#[doc = " A client operating in synchronous mode cannot call ::NvEncLockBitstream()"]
#[doc = " API on the output bitstream buffer if ::NvEncEncodePicture() returned the"]
#[doc = " ::NV_ENC_ERR_NEED_MORE_INPUT error code."]
#[doc = " The client must continue providing input frames until encode driver returns"]
#[doc = " ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call"]
#[doc = " ::NvEncLockBitstream() API on the output buffers in the same order in which"]
#[doc = " it has called ::NvEncEncodePicture()."]
pub const _NVENCSTATUS_NV_ENC_ERR_NEED_MORE_INPUT: _NVENCSTATUS = 17;
#[doc = " This indicates that the HW encoder is busy encoding and is unable to encode"]
#[doc = " the input. The client should call ::NvEncEncodePicture() again after few"]
#[doc = " milliseconds."]
pub const _NVENCSTATUS_NV_ENC_ERR_ENCODER_BUSY: _NVENCSTATUS = 18;
#[doc = " This indicates that the completion event passed in ::NvEncEncodePicture()"]
#[doc = " API has not been registered with encoder driver using ::NvEncRegisterAsyncEvent()."]
pub const _NVENCSTATUS_NV_ENC_ERR_EVENT_NOT_REGISTERD: _NVENCSTATUS = 19;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const _NVENCSTATUS_NV_ENC_ERR_GENERIC: _NVENCSTATUS = 20;
#[doc = " This indicates that the client is attempting to use a feature"]
#[doc = " that is not available for the license type for the current system."]
pub const _NVENCSTATUS_NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY: _NVENCSTATUS = 21;
#[doc = " This indicates that the client is attempting to use a feature"]
#[doc = " that is not implemented for the current version."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNIMPLEMENTED: _NVENCSTATUS = 22;
#[doc = " This indicates that the ::NvEncRegisterResource API failed to register the resource."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_REGISTER_FAILED: _NVENCSTATUS = 23;
#[doc = " This indicates that the client is attempting to unregister a resource"]
#[doc = " that has not been successfully registered."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_NOT_REGISTERED: _NVENCSTATUS = 24;
#[doc = " This indicates that the client is attempting to unmap a resource"]
#[doc = " that has not been successfully mapped."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_NOT_MAPPED: _NVENCSTATUS = 25;
#[doc = " Error Codes"]
pub type _NVENCSTATUS = u32;
#[doc = " Error Codes"]
pub use self::_NVENCSTATUS as NVENCSTATUS;
#[doc = "< Memory heap to be decided by the encoder driver based on the usage"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_AUTOSELECT: _NV_ENC_MEMORY_HEAP = 0;
#[doc = "< Memory heap is in local video memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_VID: _NV_ENC_MEMORY_HEAP = 1;
#[doc = "< Memory heap is in cached system memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_SYSMEM_CACHED: _NV_ENC_MEMORY_HEAP = 2;
#[doc = "< Memory heap is in uncached system memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED: _NV_ENC_MEMORY_HEAP = 3;
#[doc = " Memory heap to allocate input and output buffers."]
pub type _NV_ENC_MEMORY_HEAP = u32;
#[doc = " Memory heap to allocate input and output buffers."]
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
#[doc = "< B frame is not used for reference"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_DISABLED: _NV_ENC_BFRAME_REF_MODE = 0;
#[doc = "< Each B-frame will be used for reference. currently not supported for H.264"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_EACH: _NV_ENC_BFRAME_REF_MODE = 1;
#[doc = "< Only(Number of B-frame)/2 th B-frame will be used for reference"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_MIDDLE: _NV_ENC_BFRAME_REF_MODE = 2;
#[doc = " B-frame used as reference modes"]
pub type _NV_ENC_BFRAME_REF_MODE = u32;
#[doc = " B-frame used as reference modes"]
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
#[doc = "< Entropy coding mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 0;
#[doc = "< Entropy coding mode is CABAC"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_CABAC:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 1;
#[doc = "< Entropy coding mode is CAVLC"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 2;
#[doc = " H.264 entropy coding modes."]
pub type _NV_ENC_H264_ENTROPY_CODING_MODE = u32;
#[doc = " H.264 entropy coding modes."]
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
#[doc = "< BDirect mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_AUTOSELECT: _NV_ENC_H264_BDIRECT_MODE =
    0;
#[doc = "< Disable BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_DISABLE: _NV_ENC_H264_BDIRECT_MODE = 1;
#[doc = "< Temporal BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_TEMPORAL: _NV_ENC_H264_BDIRECT_MODE =
    2;
#[doc = "< Spatial BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_SPATIAL: _NV_ENC_H264_BDIRECT_MODE = 3;
#[doc = " H.264 specific Bdirect modes"]
pub type _NV_ENC_H264_BDIRECT_MODE = u32;
#[doc = " H.264 specific Bdirect modes"]
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
#[doc = "< FMO usage is auto selected by the encoder driver"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_AUTOSELECT: _NV_ENC_H264_FMO_MODE = 0;
#[doc = "< Enable FMO"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_ENABLE: _NV_ENC_H264_FMO_MODE = 1;
#[doc = "< Disble FMO"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_DISABLE: _NV_ENC_H264_FMO_MODE = 2;
#[doc = " H.264 specific FMO usage"]
pub type _NV_ENC_H264_FMO_MODE = u32;
#[doc = " H.264 specific FMO usage"]
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
#[doc = "< Adaptive Transform 8x8 mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 0;
#[doc = "< Adaptive Transform 8x8 mode disabled"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 1;
#[doc = "< Adaptive Transform 8x8 mode should be used"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 2;
#[doc = " H.264 specific Adaptive Transform modes"]
pub type _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = u32;
#[doc = " H.264 specific Adaptive Transform modes"]
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
#[doc = "< No Stereo packing required"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_NONE: _NV_ENC_STEREO_PACKING_MODE =
    0;
#[doc = "< Checkerboard mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD:
    _NV_ENC_STEREO_PACKING_MODE = 1;
#[doc = "< Column Interleave mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE:
    _NV_ENC_STEREO_PACKING_MODE = 2;
#[doc = "< Row Interleave mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE:
    _NV_ENC_STEREO_PACKING_MODE = 3;
#[doc = "< Side-by-side mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE:
    _NV_ENC_STEREO_PACKING_MODE = 4;
#[doc = "< Top-Bottom mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM:
    _NV_ENC_STEREO_PACKING_MODE = 5;
#[doc = "< Frame Sequential mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_FRAMESEQ:
    _NV_ENC_STEREO_PACKING_MODE = 6;
#[doc = " Stereo frame packing modes."]
pub type _NV_ENC_STEREO_PACKING_MODE = u32;
#[doc = " Stereo frame packing modes."]
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
#[doc = "< input resource type is a directx9 surface"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX:
    _NV_ENC_INPUT_RESOURCE_TYPE = 0;
#[doc = "< input resource type is a cuda device pointer surface"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR:
    _NV_ENC_INPUT_RESOURCE_TYPE = 1;
#[doc = "< input resource type is a cuda array surface."]
#[doc = "This array must be a 2D array and the CUDA_ARRAY3D_SURFACE_LDST"]
#[doc = "flag must have been specified when creating it."]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY:
    _NV_ENC_INPUT_RESOURCE_TYPE = 2;
#[doc = "< input resource type is an OpenGL texture"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX:
    _NV_ENC_INPUT_RESOURCE_TYPE = 3;
#[doc = "  Input Resource type"]
pub type _NV_ENC_INPUT_RESOURCE_TYPE = u32;
#[doc = "  Input Resource type"]
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
#[doc = "< Registered surface will be used for input image"]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_INPUT_IMAGE: _NV_ENC_BUFFER_USAGE = 0;
#[doc = "< Registered surface will be used for output of H.264 ME only mode."]
#[doc = "This buffer usage type is not supported for HEVC ME only mode."]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_OUTPUT_MOTION_VECTOR: _NV_ENC_BUFFER_USAGE = 1;
#[doc = "< Registered surface will be used for output bitstream in encoding"]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_OUTPUT_BITSTREAM: _NV_ENC_BUFFER_USAGE = 2;
#[doc = "  Buffer usage"]
pub type _NV_ENC_BUFFER_USAGE = u32;
#[doc = "  Buffer usage"]
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
#[doc = "< encode device type is a directx9 device"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_DIRECTX: _NV_ENC_DEVICE_TYPE = 0;
#[doc = "< encode device type is a cuda device"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_CUDA: _NV_ENC_DEVICE_TYPE = 1;
#[doc = "< encode device type is an OpenGL device."]
#[doc = "Use of this device type is supported only on Linux"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_OPENGL: _NV_ENC_DEVICE_TYPE = 2;
#[doc = "  Encoder Device type"]
pub type _NV_ENC_DEVICE_TYPE = u32;
#[doc = "  Encoder Device type"]
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
#[doc = "< Number of reference frames is auto selected by the encoder driver"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_AUTOSELECT: _NV_ENC_NUM_REF_FRAMES = 0;
#[doc = "< Number of reference frames equal to 1"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_1: _NV_ENC_NUM_REF_FRAMES = 1;
#[doc = "< Number of reference frames equal to 2"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_2: _NV_ENC_NUM_REF_FRAMES = 2;
#[doc = "< Number of reference frames equal to 3"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_3: _NV_ENC_NUM_REF_FRAMES = 3;
#[doc = "< Number of reference frames equal to 4"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_4: _NV_ENC_NUM_REF_FRAMES = 4;
#[doc = "< Number of reference frames equal to 5"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_5: _NV_ENC_NUM_REF_FRAMES = 5;
#[doc = "< Number of reference frames equal to 6"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_6: _NV_ENC_NUM_REF_FRAMES = 6;
#[doc = "< Number of reference frames equal to 7"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_7: _NV_ENC_NUM_REF_FRAMES = 7;
#[doc = " Number of reference frames"]
pub type _NV_ENC_NUM_REF_FRAMES = u32;
#[doc = " Number of reference frames"]
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
#[doc = " Maximum number of B-Frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_BFRAMES: _NV_ENC_CAPS = 0;
#[doc = " Rate control modes supported."]
#[doc = " \\n The API return value is a bitmask of the values in NV_ENC_PARAMS_RC_MODE."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES: _NV_ENC_CAPS = 1;
#[doc = " Indicates HW support for field mode encoding."]
#[doc = " \\n 0 : Interlaced mode encoding is not supported."]
#[doc = " \\n 1 : Interlaced field mode encoding is supported."]
#[doc = " \\n 2 : Interlaced frame encoding and field mode encoding are both supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_FIELD_ENCODING: _NV_ENC_CAPS = 2;
#[doc = " Indicates HW support for monochrome mode encoding."]
#[doc = " \\n 0 : Monochrome mode not supported."]
#[doc = " \\n 1 : Monochrome mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MONOCHROME: _NV_ENC_CAPS = 3;
#[doc = " Indicates HW support for FMO."]
#[doc = " \\n 0 : FMO not supported."]
#[doc = " \\n 1 : FMO supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_FMO: _NV_ENC_CAPS = 4;
#[doc = " Indicates HW capability for Quarter pel motion estimation."]
#[doc = " \\n 0 : QuarterPel Motion Estimation not supported."]
#[doc = " \\n 1 : QuarterPel Motion Estimation supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_QPELMV: _NV_ENC_CAPS = 5;
#[doc = " H.264 specific. Indicates HW support for BDirect modes."]
#[doc = " \\n 0 : BDirect mode encoding not supported."]
#[doc = " \\n 1 : BDirect mode encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_BDIRECT_MODE: _NV_ENC_CAPS = 6;
#[doc = " H264 specific. Indicates HW support for CABAC entropy coding mode."]
#[doc = " \\n 0 : CABAC entropy coding not supported."]
#[doc = " \\n 1 : CABAC entropy coding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CABAC: _NV_ENC_CAPS = 7;
#[doc = " Indicates HW support for Adaptive Transform."]
#[doc = " \\n 0 : Adaptive Transform not supported."]
#[doc = " \\n 1 : Adaptive Transform supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM: _NV_ENC_CAPS = 8;
#[doc = " Indicates HW support for Multi View Coding."]
#[doc = " \\n 0 : Multi View Coding not supported."]
#[doc = " \\n 1 : Multi View Coding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_STEREO_MVC: _NV_ENC_CAPS = 9;
#[doc = " Indicates HW support for encoding Temporal layers."]
#[doc = " \\n 0 : Encoding Temporal layers not supported."]
#[doc = " \\n 1 : Encoding Temporal layers supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS: _NV_ENC_CAPS = 10;
#[doc = " Indicates HW support for Hierarchical P frames."]
#[doc = " \\n 0 : Hierarchical P frames not supported."]
#[doc = " \\n 1 : Hierarchical P frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES: _NV_ENC_CAPS = 11;
#[doc = " Indicates HW support for Hierarchical B frames."]
#[doc = " \\n 0 : Hierarchical B frames not supported."]
#[doc = " \\n 1 : Hierarchical B frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES: _NV_ENC_CAPS = 12;
#[doc = " Maximum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_LEVEL_MAX: _NV_ENC_CAPS = 13;
#[doc = " Minimum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_LEVEL_MIN: _NV_ENC_CAPS = 14;
#[doc = " Indicates HW support for separate colour plane encoding."]
#[doc = " \\n 0 : Separate colour plane encoding not supported."]
#[doc = " \\n 1 : Separate colour plane encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SEPARATE_COLOUR_PLANE: _NV_ENC_CAPS = 15;
#[doc = " Maximum output width supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_WIDTH_MAX: _NV_ENC_CAPS = 16;
#[doc = " Maximum output height supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_HEIGHT_MAX: _NV_ENC_CAPS = 17;
#[doc = " Indicates Temporal Scalability Support."]
#[doc = " \\n 0 : Temporal SVC encoding not supported."]
#[doc = " \\n 1 : Temporal SVC encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC: _NV_ENC_CAPS = 18;
#[doc = " Indicates Dynamic Encode Resolution Change Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Dynamic Encode Resolution Change not supported."]
#[doc = " \\n 1 : Dynamic Encode Resolution Change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE: _NV_ENC_CAPS = 19;
#[doc = " Indicates Dynamic Encode Bitrate Change Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Dynamic Encode bitrate change not supported."]
#[doc = " \\n 1 : Dynamic Encode bitrate change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE: _NV_ENC_CAPS = 20;
#[doc = " Indicates Forcing Constant QP On The Fly Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Forcing constant QP on the fly not supported."]
#[doc = " \\n 1 : Forcing constant QP on the fly supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP: _NV_ENC_CAPS = 21;
#[doc = " Indicates Dynamic rate control mode Change Support."]
#[doc = " \\n 0 : Dynamic rate control mode change not supported."]
#[doc = " \\n 1 : Dynamic rate control mode change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE: _NV_ENC_CAPS = 22;
#[doc = " Indicates Subframe readback support for slice-based encoding."]
#[doc = " \\n 0 : Subframe readback not supported."]
#[doc = " \\n 1 : Subframe readback supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK: _NV_ENC_CAPS = 23;
#[doc = " Indicates Constrained Encoding mode support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Constrained encoding mode not supported."]
#[doc = " \\n 1 : Constarined encoding mode supported."]
#[doc = " If this mode is supported client can enable this during initialisation."]
#[doc = " Client can then force a picture to be coded as constrained picture where"]
#[doc = " each slice in a constrained picture will have constrained_intra_pred_flag set to 1"]
#[doc = " and disable_deblocking_filter_idc will be set to 2 and prediction vectors for inter"]
#[doc = " macroblocks in each slice will be restricted to the slice region."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING: _NV_ENC_CAPS = 24;
#[doc = " Indicates Intra Refresh Mode Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Intra Refresh Mode not supported."]
#[doc = " \\n 1 : Intra Refresh Mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_INTRA_REFRESH: _NV_ENC_CAPS = 25;
#[doc = " Indicates Custom VBV Bufer Size support. It can be used for capping frame size."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Custom VBV buffer size specification from client, not supported."]
#[doc = " \\n 1 : Custom VBV buffer size specification from client, supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE: _NV_ENC_CAPS = 26;
#[doc = " Indicates Dynamic Slice Mode Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Dynamic Slice Mode not supported."]
#[doc = " \\n 1 : Dynamic Slice Mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE: _NV_ENC_CAPS = 27;
#[doc = " Indicates Reference Picture Invalidation Support."]
#[doc = " Support added from NvEncodeAPI version 2.0."]
#[doc = " \\n 0 : Reference Picture Invalidation not supported."]
#[doc = " \\n 1 : Reference Picture Invalidation supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION: _NV_ENC_CAPS = 28;
#[doc = " Indicates support for PreProcessing."]
#[doc = " The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS"]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_PREPROC_SUPPORT: _NV_ENC_CAPS = 29;
#[doc = " Indicates support Async mode."]
#[doc = " \\n 0 : Async Encode mode not supported."]
#[doc = " \\n 1 : Async Encode mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT: _NV_ENC_CAPS = 30;
#[doc = " Maximum MBs per frame supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_MB_NUM_MAX: _NV_ENC_CAPS = 31;
#[doc = " Maximum aggregate throughput in MBs per sec."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_MB_PER_SEC_MAX: _NV_ENC_CAPS = 32;
#[doc = " Indicates HW support for YUV444 mode encoding."]
#[doc = " \\n 0 : YUV444 mode encoding not supported."]
#[doc = " \\n 1 : YUV444 mode encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_YUV444_ENCODE: _NV_ENC_CAPS = 33;
#[doc = " Indicates HW support for lossless encoding."]
#[doc = " \\n 0 : lossless encoding not supported."]
#[doc = " \\n 1 : lossless encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE: _NV_ENC_CAPS = 34;
#[doc = " Indicates HW support for Sample Adaptive Offset."]
#[doc = " \\n 0 : SAO not supported."]
#[doc = " \\n 1 : SAO encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_SAO: _NV_ENC_CAPS = 35;
#[doc = " Indicates HW support for MEOnly Mode."]
#[doc = " \\n 0 : MEOnly Mode not supported."]
#[doc = " \\n 1 : MEOnly Mode supported for I and P frames."]
#[doc = " \\n 2 : MEOnly Mode supported for I, P and B frames."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MEONLY_MODE: _NV_ENC_CAPS = 36;
#[doc = " Indicates HW support for lookahead encoding (enableLookahead=1)."]
#[doc = " \\n 0 : Lookahead not supported."]
#[doc = " \\n 1 : Lookahead supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_LOOKAHEAD: _NV_ENC_CAPS = 37;
#[doc = " Indicates HW support for temporal AQ encoding (enableTemporalAQ=1)."]
#[doc = " \\n 0 : Temporal AQ not supported."]
#[doc = " \\n 1 : Temporal AQ supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ: _NV_ENC_CAPS = 38;
#[doc = " Indicates HW support for 10 bit encoding."]
#[doc = " \\n 0 : 10 bit encoding not supported."]
#[doc = " \\n 1 : 10 bit encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_10BIT_ENCODE: _NV_ENC_CAPS = 39;
#[doc = " Maximum number of Long Term Reference frames supported"]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_LTR_FRAMES: _NV_ENC_CAPS = 40;
#[doc = " Indicates HW support for Weighted Predicition."]
#[doc = " \\n 0 : Weighted Predicition not supported."]
#[doc = " \\n 1 : Weighted Predicition supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION: _NV_ENC_CAPS = 41;
#[doc = " On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used"]
#[doc = " to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity."]
#[doc = " This API can be called at any time; i.e. during the encode session or before opening the encode session."]
#[doc = " If the available encoder capacity is returned as zero, applications may choose to switch to software encoding"]
#[doc = " and continue to call this API (e.g. polling once per second) until capacity becomes available."]
#[doc = ""]
#[doc = " On baremetal (non-virtualized GPU) and linux platforms, this API always returns 100."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY: _NV_ENC_CAPS = 42;
#[doc = " Indicates B as refererence support."]
#[doc = " \\n 0 : B as reference is not supported."]
#[doc = " \\n 1 : each B-Frame as reference is supported."]
#[doc = " \\n 2 : only Middle B-frame as reference is supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE: _NV_ENC_CAPS = 43;
#[doc = " Indicates HW support for Emphasis Level Map based delta QP computation."]
#[doc = " \\n 0 : Emphasis Level Map based delta QP not supported."]
#[doc = " \\n 1 : Emphasis Level Map based delta QP is supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP: _NV_ENC_CAPS = 44;
#[doc = " Minimum input width supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_WIDTH_MIN: _NV_ENC_CAPS = 45;
#[doc = " Minimum input height supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_HEIGHT_MIN: _NV_ENC_CAPS = 46;
#[doc = " Indicates HW support for multiple reference frames."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES: _NV_ENC_CAPS = 47;
#[doc = " Reserved - Not to be used by clients."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_EXPOSED_COUNT: _NV_ENC_CAPS = 48;
#[doc = " Encoder capabilities enumeration."]
pub type _NV_ENC_CAPS = u32;
#[doc = " Encoder capabilities enumeration."]
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_AUTOSELECT: _NV_ENC_HEVC_CUSIZE = 0;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_8x8: _NV_ENC_HEVC_CUSIZE = 1;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_16x16: _NV_ENC_HEVC_CUSIZE = 2;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_32x32: _NV_ENC_HEVC_CUSIZE = 3;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_64x64: _NV_ENC_HEVC_CUSIZE = 4;
#[doc = "  HEVC CU SIZE"]
pub type _NV_ENC_HEVC_CUSIZE = u32;
#[doc = "  HEVC CU SIZE"]
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
#[doc = " Input struct for querying Encoding capabilities."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CAPS_PARAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CAPS_PARAM_VER"]
    pub version: u32,
    #[doc = "< [in]: Specifies the encode capability to be queried. Client should pass a member for ::NV_ENC_CAPS enum."]
    pub capsToQuery: NV_ENC_CAPS,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CAPS_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CAPS_PARAM>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CAPS_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).capsToQuery as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(capsToQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CAPS_PARAM>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Input struct for querying Encoding capabilities."]
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[doc = " Creation parameters for input buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_INPUT_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Input buffer width"]
    pub width: u32,
    #[doc = "< [in]: Input buffer width"]
    pub height: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Input buffer format"]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to input buffer"]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Pointer to existing sysmem buffer"]
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 57usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).memoryHeap as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).bufferFmt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).pSysMemBuffer as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(pSysMemBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for input buffer."]
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[doc = " Creation parameters for output bitstream buffer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_BITSTREAM_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub size: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to the output bitstream buffer"]
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Reserved and should not be used"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 58usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_BITSTREAM_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).memoryHeap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).bitstreamBufferPtr
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved1 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_BITSTREAM_BUFFER>())).reserved2 as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output bitstream buffer."]
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [out]: Pointer to the output motion vector buffer"]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_MV_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).mvBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CREATE_MV_BUFFER>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[doc = " QP value for frames"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_QP {
    #[doc = "< [in]: Specifies QP value for P-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterP: u32,
    #[doc = "< [in]: Specifies QP value for B-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterB: u32,
    #[doc = "< [in]: Specifies QP value for Intra Frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpIntra: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_QP() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_QP>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_QP>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpInterB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_QP>())).qpIntra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpIntra)
        )
    );
}
#[doc = " QP value for frames"]
pub type NV_ENC_QP = _NV_ENC_QP;
#[doc = " Rate Control Configuration Paramters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    #[doc = "< [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps."]
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    #[doc = "< [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode."]
    pub constQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the average bitrate(in bits/sec) used for encoding."]
    pub averageBitRate: u32,
    #[doc = "< [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode."]
    pub maxBitRate: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size."]
    pub vbvBufferSize: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay ."]
    pub vbvInitialDelay: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1."]
    pub minQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1."]
    pub maxQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1."]
    pub initialRCQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the temporal layers (as a bitmask) whose QPs have changed. Valid max bitmask is [2^NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS - 1]"]
    pub temporallayerIdxMask: u32,
    #[doc = "< [in]: Specifies the temporal layer QPs used for rate control. Temporal layer index is used as as the array index"]
    pub temporalLayerQP: [u8; 8usize],
    #[doc = "< [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)"]
    pub targetQuality: u8,
    #[doc = "< [in]: Fractional part of target quality (as 8.8 fixed point format)"]
    pub targetQualityLSB: u8,
    #[doc = "< [in]: Maximum depth of lookahead with range 0-32 (only used if enableLookahead=1)"]
    pub lookaheadDepth: u16,
    pub reserved1: u32,
    #[doc = "< [in]: This flag is used to interpret values in array specified by NV_ENC_PIC_PARAMS::qpDeltaMap."]
    #[doc = "Set this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map."]
    #[doc = "Emphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL."]
    #[doc = "Emphasis Level Map is used to specify regions to be encoded at varying levels of quality."]
    #[doc = "The hardware encoder adjusts the quantization within the image as per the provided emphasis map,"]
    #[doc = "by adjusting the quantization parameter (QP) assigned to each macroblock. This adjustment is commonly called Delta QP."]
    #[doc = "The adjustment depends on the absolute QP decided by the rate control algorithm, and is applied after the rate control has decided each macroblocks QP."]
    #[doc = "Since the Delta QP overrides rate control, enabling Emphasis Level Map may violate bitrate and VBV buffer size constraints."]
    #[doc = "Emphasis Level Map is useful in situations where client has a priori knowledge of the image complexity (e.g. via use of NVFBC's Classification feature) and encoding those high-complexity areas at higher quality (lower QP) is important, even at the possible cost of violating bitrate/VBV buffer size constraints"]
    #[doc = "This feature is not supported when AQ( Spatial/Temporal) is enabled."]
    #[doc = "This feature is only supported for H264 codec currently."]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QPDelta. This specifies QP modifier to be applied on top of the QP chosen by rate control"]
    #[doc = ""]
    #[doc = "Set this to NV_ENC_QP_MAP_DISABLED to ignore NV_ENC_PIC_PARAMS::qpDeltaMap values. In this case, qpDeltaMap should be set to NULL."]
    #[doc = ""]
    #[doc = "Other values are reserved for future use."]
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    pub reserved: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_RC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RC_PARAMS>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).rateControlMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(rateControlMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).constQP as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(constQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).averageBitRate as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(averageBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxBitRate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxBitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvBufferSize as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).vbvInitialDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvInitialDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).minQP as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(minQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).maxQP as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).initialRCQP as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(initialRCQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporallayerIdxMask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporallayerIdxMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).temporalLayerQP as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporalLayerQP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQuality as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQuality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).targetQualityLSB as *const _ as usize
        },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQualityLSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).lookaheadDepth as *const _ as usize
        },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lookaheadDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved1 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).qpMapMode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(qpMapMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_RC_PARAMS>())).reserved as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Rate Control Configuration Paramters"]
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    #[doc = "< [in]: if set to 1 , it specifies that the overscanInfo is present"]
    pub overscanInfoPresentFlag: u32,
    #[doc = "< [in]: Specifies the overscan info(as defined in Annex E of the ITU-T Specification)."]
    pub overscanInfo: u32,
    #[doc = "< [in]: If set to 1, it specifies  that the videoFormat, videoFullRangeFlag and colourDescriptionPresentFlag are present."]
    pub videoSignalTypePresentFlag: u32,
    #[doc = "< [in]: Specifies the source video format(as defined in Annex E of the ITU-T Specification)."]
    pub videoFormat: u32,
    #[doc = "< [in]: Specifies the output range of the luma and chroma samples(as defined in Annex E of the ITU-T Specification)."]
    pub videoFullRangeFlag: u32,
    #[doc = "< [in]: If set to 1, it specifies that the colourPrimaries, transferCharacteristics and colourMatrix are present."]
    pub colourDescriptionPresentFlag: u32,
    #[doc = "< [in]: Specifies color primaries for converting to RGB(as defined in Annex E of the ITU-T Specification)"]
    pub colourPrimaries: u32,
    #[doc = "< [in]: Specifies the opto-electronic transfer characteristics to use (as defined in Annex E of the ITU-T Specification)"]
    pub transferCharacteristics: u32,
    #[doc = "< [in]: Specifies the matrix coefficients used in deriving the luma and chroma from the RGB primaries (as defined in Annex E of the ITU-T Specification)."]
    pub colourMatrix: u32,
    #[doc = "< [in]: if set to 1 , it specifies that the chromaSampleLocationTop and chromaSampleLocationBot are present."]
    pub chromaSampleLocationFlag: u32,
    #[doc = "< [in]: Specifies the chroma sample location for top field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationTop: u32,
    #[doc = "< [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationBot: u32,
    #[doc = "< [in]: if set to 1, it specifies the bitstream restriction parameters are present in the bitstream."]
    pub bitstreamRestrictionFlag: u32,
    pub reserved: [u32; 15usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_VUI_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        112usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfoPresentFlag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).overscanInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .videoSignalTypePresentFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoSignalTypePresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFormat as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).videoFullRangeFlag
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFullRangeFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>()))
                .colourDescriptionPresentFlag as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourDescriptionPresentFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourPrimaries
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).transferCharacteristics
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).colourMatrix as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationFlag
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationTop
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationTop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).chromaSampleLocationBot
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationBot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).bitstreamRestrictionFlag
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(bitstreamRestrictionFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>())).reserved as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS"]
#[doc = " H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Reserved for future use."]
    pub reserved1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE),
            "::",
            stringify!(reserved1)
        )
    );
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"]
#[doc = " External motion vector hint counts per block type."]
#[doc = " H264 supports multiple hint while HEVC supports one hint for each valid candidate."]
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT"]
#[doc = " External Motion Vector hint structure."]
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = "< [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level."]
    pub level: u32,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Set to 1 to enable 4:4:4 separate colour planes"]
    pub separateColourPlaneFlag: u32,
    #[doc = "< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]"]
    pub disableDeblockingFilterIDC: u32,
    #[doc = "< [in]: Specifies max temporal layers to be used for hierarchical coding. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS]"]
    pub numTemporalLayers: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: Specifies the AdaptiveTransform Mode. Check support for AdaptiveTransform mode using ::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM caps."]
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    #[doc = "< [in]: Specified the FMO Mode. Check support for FMO using ::NV_ENC_CAPS_SUPPORT_FMO caps."]
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    #[doc = "< [in]: Specifies the BDirect mode. Check support for BDirect mode using ::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE caps."]
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    #[doc = "< [in]: Specifies the entropy coding mode. Check support for CABAC mode using ::NV_ENC_CAPS_SUPPORT_CABAC caps."]
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    #[doc = "< [in]: Specifies the stereo frame packing mode which is to be signalled in frame packing arrangement SEI"]
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default dpb size."]
    #[doc = "The low latency application which wants to invalidate reference frame as an error resilience tool"]
    #[doc = "is recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent"]
    #[doc = "frames are invalidated."]
    pub maxNumRefFrames: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3 numSlices in Picture."]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the H264 video usability info pamameters"]
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the number of LTR frames. This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_H264::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input."]
    #[doc = "Check support for YUV444 encoding using ::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE caps."]
    pub chromaFormatIDC: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayers: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 267usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).idrPeriod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).separateColourPlaneFlag as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(separateColourPlaneFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).disableDeblockingFilterIDC as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(disableDeblockingFilterIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numTemporalLayers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).spsId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ppsId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).adaptiveTransformMode as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(adaptiveTransformMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).fmoMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(fmoMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).bdirectMode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(bdirectMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).entropyCodingMode as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(entropyCodingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).stereoMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(stereoMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshPeriod as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).intraRefreshCnt as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxNumRefFrames as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxNumRefFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceMode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).sliceModeData as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).h264VUIParameters as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(h264VUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrNumFrames as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).ltrTrustMode as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).chromaFormatIDC as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(chromaFormatIDC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).maxTemporalLayers as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxTemporalLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).useBFramesAsRef as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL0 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).numRefL1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved1 as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264>())).reserved2 as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264"]
#[doc = " H264 encoder configuration parameters"]
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC {
    #[doc = "< [in]: Specifies the level of the encoded bitstream."]
    pub level: u32,
    #[doc = "< [in]: Specifies the level tier of the encoded bitstream."]
    pub tier: u32,
    #[doc = "< [in]: Specifies the minimum size of luma coding unit."]
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    #[doc = "< [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32."]
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set."]
    #[doc = "Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the maximum number of references frames in the DPB."]
    pub maxNumRefFramesInDPB: u32,
    #[doc = "< [in]: This parameter has different meaning in two LTR modes."]
    #[doc = "In \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR."]
    #[doc = "In \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the VPS id of the video parameter set"]
    pub vpsId: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayersMinus1: u32,
    #[doc = "< [in]: Specifies the HEVC video usability info pamameters"]
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_HEVC::enableLTR for description of the two modes."]
    #[doc = "Set to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may"]
    #[doc = "be deprecated in future releases."]
    #[doc = "Set to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame."]
    #[doc = "Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 214usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC>(),
        1560usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).tier as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).minCUSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(minCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxCUSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxCUSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).idrPeriod as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshPeriod as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).intraRefreshCnt as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxNumRefFramesInDPB as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrNumFrames as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).vpsId as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(vpsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).spsId as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ppsId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceMode as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).sliceModeData as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).maxTemporalLayersMinus1 as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).hevcVUIParameters as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(hevcVUIParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).ltrTrustMode as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).useBFramesAsRef as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL0 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).numRefL1 as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC>())).reserved2 as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        enableFillerDataInsertion: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC"]
#[doc = " HEVC encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_H264_MEONLY>())).reserved2 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY"]
#[doc = " H264 encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 256usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC_MEONLY() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG_HEVC_MEONLY>())).reserved1 as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY"]
#[doc = " HEVC encoder configuration parameters for ME only Mode"]
#[doc = ""]
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    #[doc = "< [in]: Specifies the H.264-specific encoder configuration."]
    pub h264Config: NV_ENC_CONFIG_H264,
    #[doc = "< [in]: Specifies the HEVC-specific encoder configuration."]
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    #[doc = "< [in]: Specifies the H.264-specific ME only encoder configuration."]
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    #[doc = "< [in]: Specifies the HEVC-specific ME only encoder configuration."]
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 320usize],
    _bindgen_union_align: [u64; 224usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_CONFIG>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264Config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264Config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcConfig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).h264MeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264MeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).hevcMeOnlyConfig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcMeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CODEC_CONFIG>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CODEC_CONFIG"]
#[doc = " Codec-specific encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the codec profile guid. If client specifies \\p NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID the NvEncodeAPI interface will select the appropriate codec profile."]
    pub profileGUID: GUID,
    #[doc = "< [in]: Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically."]
    pub gopLength: u32,
    #[doc = "< [in]: Specifies the GOP pattern as follows: \\p frameIntervalP = 0: I, 1: IPP, 2: IBP, 3: IBBP  If goplength is set to NVENC_INFINITE_GOPLENGTH \\p frameIntervalP should be set to 1."]
    pub frameIntervalP: i32,
    #[doc = "< [in]: Set this to 1 to enable monochrome encoding for this session."]
    pub monoChromeEncoding: u32,
    #[doc = "< [in]: Specifies the frame/field mode."]
    #[doc = "Check support for field encoding using ::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING caps."]
    #[doc = "Using a frameFieldMode other than NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME for RGB input is not supported."]
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    #[doc = "< [in]: Specifies the desired motion vector prediction precision."]
    pub mvPrecision: NV_ENC_MV_PRECISION,
    #[doc = "< [in]: Specifies the rate control parameters for the current encoding session."]
    pub rcParams: NV_ENC_RC_PARAMS,
    #[doc = "< [in]: Specifies the codec specific config parameters through this union."]
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 278usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG>(),
        3584usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).profileGUID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(profileGUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).gopLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(gopLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameIntervalP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameIntervalP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).monoChromeEncoding as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(monoChromeEncoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).frameFieldMode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameFieldMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).mvPrecision as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(mvPrecision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).rcParams as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(rcParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).encodeCodecConfig as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(encodeCodecConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved as *const _ as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_CONFIG>())).reserved2 as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG"]
#[doc = " Encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the Encode GUID for which the encoder is being created. ::NvEncInitializeEncoder() API will fail if this is not set, or set to unsupported value."]
    pub encodeGUID: GUID,
    #[doc = "< [in]: Specifies the preset for encoding. If the preset GUID is set then , the preset configuration will be applied before any other parameter."]
    pub presetGUID: GUID,
    #[doc = "< [in]: Specifies the encode width. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeWidth: u32,
    #[doc = "< [in]: Specifies the encode height. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeHeight: u32,
    #[doc = "< [in]: Specifies the display aspect ratio Width."]
    pub darWidth: u32,
    #[doc = "< [in]: Specifies the display aspect ratio height."]
    pub darHeight: u32,
    #[doc = "< [in]: Specifies the numerator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateNum: u32,
    #[doc = "< [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateDen: u32,
    #[doc = "< [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification."]
    pub enableEncodeAsync: u32,
    #[doc = "< [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface."]
    pub enablePTD: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Reserved private data buffer size and must be set to 0"]
    pub privDataSize: u32,
    #[doc = "< [in]: Reserved private data buffer and must be set to NULL"]
    pub privData: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters."]
    #[doc = "Client can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS."]
    #[doc = "Even in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API."]
    pub encodeConfig: *mut NV_ENC_CONFIG,
    #[doc = "< [in]: Maximum encode width to be used for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encoder will not allow dynamic resolution change."]
    pub maxEncodeWidth: u32,
    #[doc = "< [in]: Maximum encode height to be allowed for current Encode session."]
    #[doc = "Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encode will not allow dynamic resolution change."]
    pub maxEncodeHeight: u32,
    #[doc = "< [in]: If Client wants to pass external motion vectors in NV_ENC_PIC_PARAMS::meExternalHints buffer it must specify the maximum number of hint candidates per block per direction for the encode session."]
    #[doc = "The NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[0] is for L0 predictors and NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "This client must also set NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints to 1."]
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 289usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INITIALIZE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        1808usize,
        concat!("Size of: ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeGUID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).presetGUID as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(presetGUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeWidth as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeHeight as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darWidth as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).darHeight as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateNum as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).frameRateDen as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateDen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enableEncodeAsync as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enableEncodeAsync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).enablePTD as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enablePTD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privDataSize as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).privData as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).encodeConfig as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeWidth as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxEncodeHeight as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).maxMEHintCountsPerBlock
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxMEHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_INITIALIZE_PARAMS>())).reserved2 as *const _ as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        enableOutputInVidmem: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::std::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS"]
#[doc = " Encode Session Initialization parameters."]
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_RECONFIGURE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Encoder session re-initialization parameters."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is the same as the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will continue to use the existing encode"]
    #[doc = "configuration."]
    #[doc = "If reInitEncodeParams.encodeConfig is NULL and"]
    #[doc = "reInitEncodeParams.presetGUID is different from the preset"]
    #[doc = "GUID specified on the call to NvEncInitializeEncoder(),"]
    #[doc = "EncodeAPI will try to use the default configuration for"]
    #[doc = "the preset specified by reInitEncodeParams.presetGUID."]
    #[doc = "In this case, reconfiguration may fail if the new"]
    #[doc = "configuration is incompatible with the existing"]
    #[doc = "configuration (e.g. the new configuration results in"]
    #[doc = "a change in the GOP structure)."]
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_RECONFIGURE_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        1824usize,
        concat!("Size of: ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_RECONFIGURE_PARAMS>())).reInitEncodeParams as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(reInitEncodeParams)
        )
    );
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS"]
#[doc = " Encode Session Reconfigured parameters."]
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [out]: preset config returned by the Nvidia Video Encoder interface."]
    pub presetCfg: NV_ENC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PRESET_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PRESET_CONFIG>(),
        5128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PRESET_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).presetCfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(presetCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved1 as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PRESET_CONFIG>())).reserved2 as *const _ as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PRESET_CONFIG"]
#[doc = " Encoder preset config"]
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_MVC_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the view ID associated with the current input view."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the temporal ID associated with the current input view."]
    pub temporalID: u32,
    #[doc = "< [in]: Specifies the priority ID associated with the current input view. Reserved and ignored by the NvEncodeAPI interface."]
    pub priorityID: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 12usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_MVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).viewID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).temporalID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(temporalID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).priorityID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(priorityID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_MVC>())).reserved2 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC"]
#[doc = " MVC-specific parameters to be sent on a per-frame basis."]
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    #[doc = "< [in]: Specifies the MVC picture parameters."]
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 32usize],
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264_EXT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).mvcPicParams as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(mvcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264_EXT>())).reserved1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT"]
#[doc = " H264 extension  picture parameters"]
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_SEI_PAYLOAD {
    #[doc = "< [in] SEI payload size in bytes. SEI payload must be byte aligned, as described in Annex D"]
    pub payloadSize: u32,
    #[doc = "< [in] SEI payload types and syntax can be found in Annex D of the H.264 Specification."]
    pub payloadType: u32,
    #[doc = "< [in] pointer to user data"]
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_SEI_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEI_PAYLOAD>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEI_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payloadType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_SEI_PAYLOAD>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD"]
#[doc = "  User SEI message"]
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the colour plane ID associated with the current input."]
    pub colourPlaneId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term referenceframe index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specfies the number of slices to be forced to Intra in the current picture."]
    #[doc = "This option along with forceIntraSliceIdx[] array needs to be used with sliceMode = 3 only"]
    pub forceIntraSliceCount: u32,
    #[doc = "< [in]: Slice indices to be forced to intra in the current picture. Each slice index should be <= num_slices_in_picture -1. Index starts from 0 for first slice."]
    #[doc = "The number of entries in this array should be equal to forceIntraSliceCount"]
    pub forceIntraSliceIdx: *mut u32,
    #[doc = "< [in]: Specifies the H264 extension config parameters using this config."]
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 210usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).refPicFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).colourPlaneId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(colourPlaneId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArrayCnt as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).seiPayloadArray as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).sliceModeData as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrMarkFrameIdx as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUseFrameBitmap as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).ltrUsageMode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceCount as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).forceIntraSliceIdx as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).h264ExtPicParams as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(h264ExtPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_H264>())).reserved2 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264"]
#[doc = " H264 specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the temporal id of the picture"]
    pub temporalId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt."]
    #[doc = "When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message"]
    #[doc = "forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3."]
    #[doc = "Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264"]
    #[doc = "Array element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I"]
    #[doc = "all other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT"]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0"]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices"]
    #[doc = "sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture"]
    #[doc = "When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting"]
    #[doc = "When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:"]
    #[doc = "sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)"]
    #[doc = "sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)"]
    #[doc = "sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)"]
    #[doc = "sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term reference frame index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved2: [u32; 244usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_HEVC() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).displayPOCSyntax as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).refPicFlag as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).temporalId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).forceIntraRefreshWithFrameCnt
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceTypeArrayCnt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceMode as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).sliceModeData as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrMarkFrameIdx as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUseFrameBitmap as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).ltrUsageMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArrayCnt as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).seiPayloadArray as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS_HEVC>())).reserved3 as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved3)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC"]
#[doc = " HEVC specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[doc = " Codec specific per-picture encoding parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    #[doc = "< [in]: H264 encode picture params."]
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    #[doc = "< [in]: HEVC encode picture params."]
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 256usize],
    _bindgen_union_align: [u64; 192usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).h264PicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(h264PicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).hevcPicParams as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(hevcPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_CODEC_PIC_PARAMS>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Codec specific per-picture encoding parameters."]
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input buffer width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input buffer height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth."]
    pub inputPitch: u32,
    #[doc = "< [in]: Specifies bit-wise OR`ed encode pic flags. See ::NV_ENC_PIC_FLAGS enum."]
    pub encodePicFlags: u32,
    #[doc = "< [in]: Specifies the frame index associated with the input frame [optional]."]
    pub frameIdx: u32,
    #[doc = "< [in]: Specifies presentation timestamp associated with the input picture."]
    pub inputTimeStamp: u64,
    #[doc = "< [in]: Specifies duration of the input picture"]
    pub inputDuration: u64,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client"]
    #[doc = "should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream."]
    #[doc = "First 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of"]
    #[doc = "NV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is"]
    #[doc = "greater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use"]
    #[doc = "the default stream."]
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies an event to be signalled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies structure of the input picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [in]: Specifies the codec specific per-picture encoding parameters."]
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    #[doc = "< [in]: Specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder intialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 6usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 2usize],
    #[doc = "< [in]: Specifies the pointer to signed byte array containing value per MB in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DELTA, qpDeltaMap specifies QP modifier per MB. This QP modifier will be applied on top of the QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB. This level value along with QP chosen by rate control is used to"]
    #[doc = "compute the QP modifier, which in turn is applied on top of QP chosen by rate control."]
    #[doc = "If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DISABLED, value in qpDeltaMap will be ignored."]
    pub qpDeltaMap: *mut i8,
    #[doc = "< [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs"]
    pub qpDeltaMapSize: u32,
    #[doc = "< [in]: Reserved bitfields and must be set to 0"]
    pub reservedBitFields: u32,
    #[doc = "< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints."]
    #[doc = "If not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0"]
    pub meHintRefPicDist: [u16; 2usize],
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: [u32; 286usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved4: [*mut ::std::os::raw::c_void; 60usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS>(),
        3344usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputPitch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).encodePicFlags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(encodePicFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).frameIdx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputTimeStamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputDuration as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).inputBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).outputBitstream as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).completionEvent as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).bufferFmt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).pictureType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).codecPicParams as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(codecPicParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintCountsPerBlock as *const _ as usize
        },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meExternalHints as *const _ as usize
        },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved1 as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved2 as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMap as *const _ as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).qpDeltaMapSize as *const _ as usize
        },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMapSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reservedBitFields as *const _ as usize
        },
        1708usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reservedBitFields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).meHintRefPicDist as *const _ as usize
        },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintRefPicDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved3 as *const _ as usize },
        1716usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_PIC_PARAMS>())).reserved4 as *const _ as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved4)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS"]
#[doc = " Encoding parameters that need to be sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_MEONLY_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_MEONLY_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input buffer width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input buffer height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the reference frame pointer"]
    pub referenceFrame: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer."]
    #[doc = "Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data."]
    #[doc = "If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must"]
    #[doc = "be equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this"]
    #[doc = "output buffer and assign it to NV_ENC_MEONLY_PARAMS::mvBuffer. All CUDA operations on this buffer must use the default stream."]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies an event to be signalled on completion of motion estimation"]
    #[doc = "of this Frame [only if operating in Asynchronous mode]."]
    #[doc = "Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies left,right viewID if NV_ENC_CONFIG_H264_MEONLY::bStereoEnable is set."]
    #[doc = "viewID can be 0,1 if bStereoEnable is set, 0 otherwise."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors."]
    #[doc = "The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder intialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock."]
    #[doc = "The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8"]
    #[doc = "+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 243usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MEONLY_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MEONLY_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MEONLY_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputWidth as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputHeight as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).inputBuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).referenceFrame as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(referenceFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).mvBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).bufferFmt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).completionEvent as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).viewID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meHintCountsPerBlock as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).meExternalHints as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_MEONLY_PARAMS>())).reserved2 as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS"]
#[doc = " MEOnly parameters that need to be sent on a per motion estimation basis."]
#[doc = " NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER."]
    pub version: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]: Pointer to the bitstream buffer being locked."]
    pub outputBitstream: *mut ::std::os::raw::c_void,
    #[doc = "< [in,out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs."]
    pub sliceOffsets: *mut u32,
    #[doc = "< [out]: Frame no. for which the bitstream is being retrieved."]
    pub frameIdx: u32,
    #[doc = "< [out]: The NvEncodeAPI interface status for the locked picture."]
    pub hwEncodeStatus: u32,
    #[doc = "< [out]: Number of slices in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1."]
    pub numSlices: u32,
    #[doc = "< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr."]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Presentation timestamp associated with the encoded output."]
    pub outputTimeStamp: u64,
    #[doc = "< [out]: Presentation duration associates with the encoded output."]
    pub outputDuration: u64,
    #[doc = "< [out]: Pointer to the generated output bitstream."]
    #[doc = "For MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to"]
    #[doc = "NV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Picture type of the encoded picture."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [out]: Structure of the generated output picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    #[doc = "< [out]: Total SATD cost for whole frame."]
    pub frameSatd: u32,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: Bitmap of LTR frames indices which were used for encoding this frame. Value of 0 if no LTR frames were used."]
    pub ltrFrameBitmap: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 13usize],
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVY: i32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 219usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_BITSTREAM() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputBitstream as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).sliceOffsets as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameIdx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).hwEncodeStatus as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(hwEncodeStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).numSlices as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamSizeInBytes as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputTimeStamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).outputDuration as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputDuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).bitstreamBufferPtr as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureType as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).pictureStruct as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameAvgQP as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).frameSatd as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameSatd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameIdx as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).ltrFrameBitmap as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).intraMBCount as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).interMBCount as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVX as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).averageMVY as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved1 as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_BITSTREAM>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::std::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM"]
#[doc = " Bitstream buffer lock parameters."]
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER."]
    pub version: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \\p bufferDataPtr."]
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Pitch of the locked input buffer."]
    pub pitch: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_INPUT_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).inputBuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).bufferDataPtr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(bufferDataPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_LOCK_INPUT_BUFFER>())).reserved2 as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER"]
#[doc = " Uncompressed Input Buffer lock parameters."]
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub subResourceIndex: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub inputResource: *mut ::std::os::raw::c_void,
    #[doc = "< [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API."]
    pub mappedResource: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer."]
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]:  Reserved and must be set to 0."]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MAP_INPUT_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).inputResource as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(inputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).registeredResource as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedResource as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).mappedBufferFmt as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedBufferFmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_MAP_INPUT_RESOURCE>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE"]
#[doc = " Map an input resource to a Nvidia Encoder Input Buffer"]
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_REGISTER_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the type of resource to be registered."]
    #[doc = "Supported values are"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR,"]
    #[doc = "::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    #[doc = "< [in]: Input buffer Width."]
    pub width: u32,
    #[doc = "< [in]: Input buffer Height."]
    pub height: u32,
    #[doc = "< [in]: Input buffer Pitch."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX resources, set this to 0."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR resources, set this to"]
    #[doc = "the pitch as obtained from cuMemAllocPitch(), or to the width in"]
    #[doc = "bytes (if this resource was created by using cuMemAlloc()). This"]
    #[doc = "value must be a multiple of 4."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY resources, set this to the"]
    #[doc = "width of the allocation in bytes (i.e."]
    #[doc = "CUDA_ARRAY3D_DESCRIPTOR::Width * CUDA_ARRAY3D_DESCRIPTOR::NumChannels)."]
    #[doc = "For ::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX resources, set this to the"]
    #[doc = "texture width multiplied by the number of components in the texture"]
    #[doc = "format."]
    pub pitch: u32,
    #[doc = "< [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces."]
    pub subResourceIndex: u32,
    #[doc = "< [in]: Handle to the resource that is being registered."]
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Buffer format of resource to be registered."]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Usage of resource to be registered."]
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 247usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_REGISTER_RESOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).pitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).subResourceIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).resourceToRegister as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceToRegister)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).registeredResource as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferFormat as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).bufferUsage as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved1 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_REGISTER_RESOURCE>())).reserved2 as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE"]
#[doc = " Register a resource for future use with the Nvidia Video Encoder Interface."]
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_STAT {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_STAT_VER."]
    pub version: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Specifies the pointer to output bitstream."]
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Size of generated bitstream in bytes."]
    pub bitStreamSize: u32,
    #[doc = "< [out]: Picture type of encoded picture. See ::NV_ENC_PIC_TYPE."]
    pub picType: u32,
    #[doc = "< [out]: Offset of last valid bytes of completed bitstream"]
    pub lastValidByteOffset: u32,
    #[doc = "< [out]: Offsets of each slice"]
    pub sliceOffsets: [u32; 16usize],
    #[doc = "< [out]: Picture number"]
    pub picIdx: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 233usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_STAT() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_STAT>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).outputBitStream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(outputBitStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).bitStreamSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(bitStreamSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_STAT>())).lastValidByteOffset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(lastValidByteOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).sliceOffsets as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).picIdx as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_STAT>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_STAT"]
#[doc = " Encode Stats structure."]
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]:  Specifies the size of the spsppsBuffer provied by the client"]
    pub inBufferSize: u32,
    #[doc = "< [in]:  Specifies the SPS id to be used in sequence header. Default value is 0."]
    pub spsId: u32,
    #[doc = "< [in]:  Specifies the PPS id to be used in picture header. Default value is 0."]
    pub ppsId: u32,
    #[doc = "< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize. It is the client's responsibility to manage this memory."]
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Size of the sequence and picture header in  bytes written by the NvEncodeAPI interface to the SPSPPSBuffer."]
    pub outSPSPPSPayloadSize: *mut u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: [u32; 250usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_SEQUENCE_PARAM_PAYLOAD() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).inBufferSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(inBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).ppsId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).spsppsBuffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsppsBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).outSPSPPSPayloadSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(outSPSPPSPayloadSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>())).reserved2 as *const _
                as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD"]
#[doc = " Sequence and picture paramaters payload."]
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[doc = " Event registration/unregistration parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_EVENT_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_EVENT_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_EVENT_PARAMS>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_EVENT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).completionEvent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_ENC_EVENT_PARAMS>())).reserved2 as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Event registration/unregistration parameters."]
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[doc = " Encoder Session Creation parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specified the device Type"]
    pub deviceType: NV_ENC_DEVICE_TYPE,
    #[doc = "< [in]: Pointer to client device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: API version. Should be set to NVENCAPI_VERSION."]
    pub apiVersion: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).deviceType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).apiVersion as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved1 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>())).reserved2 as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Encoder Session Creation parameters"]
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
#[doc = " \\cond API PFN"]
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    #[doc = "< [in]: Client should pass NV_ENCODE_API_FUNCTION_LIST_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and should be set to 0."]
    pub reserved: u32,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDCount() API through this pointer."]
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDCount() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDs() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDs() API through this pointer."]
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormatCount() API through this pointer."]
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormats() API through this pointer."]
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeCaps() API through this pointer."]
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetCount() API through this pointer."]
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetGUIDs() API through this pointer."]
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfig() API through this pointer."]
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    #[doc = "< [out]: Client should access ::NvEncInitializeEncoder() API through this pointer."]
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    #[doc = "< [out]: Client should access ::NvEncCreateInputBuffer() API through this pointer."]
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyInputBuffer() API through this pointer."]
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncCreateBitstreamBuffer() API through this pointer."]
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyBitstreamBuffer() API through this pointer."]
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncEncodePicture() API through this pointer."]
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    #[doc = "< [out]: Client should access ::NvEncLockBitstream() API through this pointer."]
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncUnlockBitstream() API through this pointer."]
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncLockInputBuffer() API through this pointer."]
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncUnlockInputBuffer() API through this pointer."]
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeStats() API through this pointer."]
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParams() API through this pointer."]
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    #[doc = "< [out]: Client should access ::NvEncRegisterAsyncEvent() API through this pointer."]
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncUnregisterAsyncEvent() API through this pointer."]
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncMapInputResource() API through this pointer."]
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnmapInputResource() API through this pointer."]
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncDestroyEncoder() API through this pointer."]
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    #[doc = "< [out]: Client should access ::NvEncInvalidateRefFrames() API through this pointer."]
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    #[doc = "< [out]: Client should access ::NvEncRegisterResource() API through this pointer."]
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnregisterResource() API through this pointer."]
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer."]
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Client should access ::NvEncCreateMVBuffer API through this pointer."]
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer."]
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer."]
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    #[doc = "< [out]: Client should access ::nvEncGetLastErrorString API through this pointer."]
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    #[doc = "< [out]: Client should access ::nvEncSetIOCudaStreams API through this pointer."]
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 279usize],
}
#[test]
fn bindgen_test_layout__NV_ENCODE_API_FUNCTION_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        2552usize,
        concat!("Size of: ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSession
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDCount
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeProfileGUIDs
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeGUIDs as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormatCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetInputFormats
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeCaps as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetCount
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetGUIDs
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetGUIDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodePresetConfig
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInitializeEncoder
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInitializeEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateInputBuffer
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyInputBuffer
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateBitstreamBuffer
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyBitstreamBuffer
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncEncodePicture as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncEncodePicture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockBitstream as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockBitstream
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockBitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncLockInputBuffer
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnlockInputBuffer
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockInputBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetEncodeStats as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeStats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetSequenceParams
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterAsyncEvent
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterAsyncEvent
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncMapInputResource
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncMapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnmapInputResource
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnmapInputResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyEncoder as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncInvalidateRefFrames
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInvalidateRefFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncOpenEncodeSessionEx
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSessionEx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRegisterResource
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncUnregisterResource
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterResource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncReconfigureEncoder
                as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncReconfigureEncoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved1 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncCreateMVBuffer as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncDestroyMVBuffer
                as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncRunMotionEstimationOnly
                as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRunMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncGetLastErrorString
                as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetLastErrorString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).nvEncSetIOCudaStreams
                as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncSetIOCudaStreams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NV_ENCODE_API_FUNCTION_LIST>())).reserved2 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\ingroup ENCODER_STRUCTURE"]
#[doc = " NV_ENCODE_API_FUNCTION_LIST"]
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NvEncInputFrame {
    pub inputPtr: *mut ::std::os::raw::c_void,
    pub chromaOffsets: [u32; 2usize],
    pub numChromaPlanes: u32,
    pub pitch: u32,
    pub chromaPitch: u32,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
}
#[test]
fn bindgen_test_layout_NvEncInputFrame() {
    assert_eq!(
        ::std::mem::size_of::<NvEncInputFrame>(),
        40usize,
        concat!("Size of: ", stringify!(NvEncInputFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<NvEncInputFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(NvEncInputFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).inputPtr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(inputPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).chromaOffsets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(chromaOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).numChromaPlanes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(numChromaPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).pitch as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).chromaPitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(chromaPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).bufferFormat as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncInputFrame>())).resourceType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncInputFrame),
            "::",
            stringify!(resourceType)
        )
    );
}
#[repr(C)]
pub struct NvEncoder__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Shared base class for different encoder interfaces."]
#[repr(C)]
pub struct NvEncoder {
    pub vtable_: *const NvEncoder__bindgen_vtable,
    pub m_bMotionEstimationOnly: bool,
    pub m_bOutputInVideoMemory: bool,
    pub m_hEncoder: *mut ::std::os::raw::c_void,
    pub m_nvenc: NV_ENCODE_API_FUNCTION_LIST,
    pub m_vInputFrames: std_vector,
    pub m_vRegisteredResources: std_vector,
    pub m_vReferenceFrames: std_vector,
    pub m_vRegisteredResourcesForReference: std_vector,
    pub m_vMappedInputBuffers: std_vector,
    pub m_vMappedRefBuffers: std_vector,
    pub m_vpCompletionEvent: std_vector,
    pub m_iToSend: i32,
    pub m_iGot: i32,
    pub m_nEncoderBuffer: i32,
    pub m_nOutputDelay: i32,
    pub m_nWidth: u32,
    pub m_nHeight: u32,
    pub m_eBufferFormat: NV_ENC_BUFFER_FORMAT,
    pub m_pDevice: *mut ::std::os::raw::c_void,
    pub m_eDeviceType: NV_ENC_DEVICE_TYPE,
    pub m_initializeParams: NV_ENC_INITIALIZE_PARAMS,
    pub m_encodeConfig: NV_ENC_CONFIG,
    pub m_bEncoderInitialized: bool,
    pub m_nExtraOutputDelay: u32,
    pub m_vBitstreamOutputBuffer: std_vector,
    pub m_vMVDataOutputBuffer: std_vector,
    pub m_nMaxEncodeWidth: u32,
    pub m_nMaxEncodeHeight: u32,
}
#[test]
fn bindgen_test_layout_NvEncoder() {
    assert_eq!(
        ::std::mem::size_of::<NvEncoder>(),
        8248usize,
        concat!("Size of: ", stringify!(NvEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<NvEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(NvEncoder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvEncoder>())).m_bMotionEstimationOnly as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_bMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvEncoder>())).m_bOutputInVideoMemory as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_bOutputInVideoMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_hEncoder as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_hEncoder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nvenc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nvenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vInputFrames as *const _ as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vInputFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvEncoder>())).m_vRegisteredResources as *const _ as usize
        },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vRegisteredResources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vReferenceFrames as *const _ as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vReferenceFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvEncoder>())).m_vRegisteredResourcesForReference as *const _
                as usize
        },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vRegisteredResourcesForReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vMappedInputBuffers as *const _ as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vMappedInputBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vMappedRefBuffers as *const _ as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vMappedRefBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vpCompletionEvent as *const _ as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vpCompletionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_iToSend as *const _ as usize },
        2744usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_iToSend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_iGot as *const _ as usize },
        2748usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_iGot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nEncoderBuffer as *const _ as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nEncoderBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nOutputDelay as *const _ as usize },
        2756usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nOutputDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nWidth as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nHeight as *const _ as usize },
        2764usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_eBufferFormat as *const _ as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_eBufferFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_pDevice as *const _ as usize },
        2776usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_pDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_eDeviceType as *const _ as usize },
        2784usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_eDeviceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_initializeParams as *const _ as usize },
        2792usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_initializeParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_encodeConfig as *const _ as usize },
        4600usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_encodeConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_bEncoderInitialized as *const _ as usize },
        8184usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_bEncoderInitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nExtraOutputDelay as *const _ as usize },
        8188usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nExtraOutputDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NvEncoder>())).m_vBitstreamOutputBuffer as *const _ as usize
        },
        8192usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vBitstreamOutputBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_vMVDataOutputBuffer as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_vMVDataOutputBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nMaxEncodeWidth as *const _ as usize },
        8240usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nMaxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoder>())).m_nMaxEncodeHeight as *const _ as usize },
        8244usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoder),
            "::",
            stringify!(m_nMaxEncodeHeight)
        )
    );
}
extern "C" {
    #[doc = "  @brief This function is used to initialize the encoder session."]
    #[doc = "  Application must call this function to initialize the encoder, before"]
    #[doc = "  starting to encode any frames."]
    #[link_name = "\u{1}_ZN9NvEncoder13CreateEncoderEPK25_NV_ENC_INITIALIZE_PARAMS"]
    pub fn NvEncoder_CreateEncoder(
        this: *mut NvEncoder,
        pEncodeParams: *const NV_ENC_INITIALIZE_PARAMS,
    );
}
extern "C" {
    #[doc = "  @brief  This function is used to destroy the encoder session."]
    #[doc = "  Application must call this function to destroy the encoder session and"]
    #[doc = "  clean up any allocated resources. The application must call EndEncode()"]
    #[doc = "  function to get any queued encoded frames before calling DestroyEncoder()."]
    #[link_name = "\u{1}_ZN9NvEncoder14DestroyEncoderEv"]
    pub fn NvEncoder_DestroyEncoder(this: *mut NvEncoder);
}
extern "C" {
    #[doc = "  @brief  This function is used to reconfigure an existing encoder session."]
    #[doc = "  Application can use this function to dynamically change the bitrate,"]
    #[doc = "  resolution and other QOS parameters. If the application changes the"]
    #[doc = "  resolution, it must set NV_ENC_RECONFIGURE_PARAMS::forceIDR."]
    #[link_name = "\u{1}_ZN9NvEncoder11ReconfigureEPK26_NV_ENC_RECONFIGURE_PARAMS"]
    pub fn NvEncoder_Reconfigure(
        this: *mut NvEncoder,
        pReconfigureParams: *const NV_ENC_RECONFIGURE_PARAMS,
    ) -> bool;
}
extern "C" {
    #[doc = "  @brief  This function is used to get the next available input buffer."]
    #[doc = "  Applications must call this function to obtain a pointer to the next"]
    #[doc = "  input buffer. The application must copy the uncompressed data to the"]
    #[doc = "  input buffer and then call EncodeFrame() function to encode it."]
    #[link_name = "\u{1}_ZN9NvEncoder17GetNextInputFrameEv"]
    pub fn NvEncoder_GetNextInputFrame(this: *mut NvEncoder) -> *const NvEncInputFrame;
}
extern "C" {
    #[doc = "  @brief  This function is used to encode a frame."]
    #[doc = "  Applications must call EncodeFrame() function to encode the uncompressed"]
    #[doc = "  data, which has been copied to an input buffer obtained from the"]
    #[doc = "  GetNextInputFrame() function."]
    #[link_name = "\u{1}_ZN9NvEncoder11EncodeFrameERSt6vectorIS0_IhSaIhEESaIS2_EEP18_NV_ENC_PIC_PARAMS"]
    pub fn NvEncoder_EncodeFrame(
        this: *mut NvEncoder,
        vPacket: *mut std_vector,
        pPicParams: *mut NV_ENC_PIC_PARAMS,
    );
}
extern "C" {
    #[doc = "  @brief  This function to flush the encoder queue."]
    #[doc = "  The encoder might be queuing frames for B picture encoding or lookahead;"]
    #[doc = "  the application must call EndEncode() to get all the queued encoded frames"]
    #[doc = "  from the encoder. The application must call this function before destroying"]
    #[doc = "  an encoder session."]
    #[link_name = "\u{1}_ZN9NvEncoder9EndEncodeERSt6vectorIS0_IhSaIhEESaIS2_EE"]
    pub fn NvEncoder_EndEncode(this: *mut NvEncoder, vPacket: *mut std_vector);
}
extern "C" {
    #[doc = "  @brief  This function is used to query hardware encoder capabilities."]
    #[doc = "  Applications can call this function to query capabilities like maximum encode"]
    #[doc = "  dimensions, support for lookahead or the ME-only mode etc."]
    #[link_name = "\u{1}_ZN9NvEncoder18GetCapabilityValueE4GUID12_NV_ENC_CAPS"]
    pub fn NvEncoder_GetCapabilityValue(
        this: *mut NvEncoder,
        guidCodec: GUID,
        capsToQuery: NV_ENC_CAPS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "   @brief  This function is used to get the current frame size based on pixel format."]
    #[link_name = "\u{1}_ZNK9NvEncoder12GetFrameSizeEv"]
    pub fn NvEncoder_GetFrameSize(this: *const NvEncoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @brief  This function is used to initialize config parameters based on"]
    #[doc = "          given codec and preset guids."]
    #[doc = "  The application can call this function to get the default configuration"]
    #[doc = "  for a certain preset. The application can either use these parameters"]
    #[doc = "  directly or override them with application-specific settings before"]
    #[doc = "  using them in CreateEncoder() function."]
    #[link_name = "\u{1}_ZN9NvEncoder26CreateDefaultEncoderParamsEP25_NV_ENC_INITIALIZE_PARAMS4GUIDS2_"]
    pub fn NvEncoder_CreateDefaultEncoderParams(
        this: *mut NvEncoder,
        pIntializeParams: *mut NV_ENC_INITIALIZE_PARAMS,
        codecGuid: GUID,
        presetGuid: GUID,
    );
}
extern "C" {
    #[doc = "  @brief  This function is used to get the current initialization parameters,"]
    #[doc = "          which had been used to configure the encoder session."]
    #[doc = "  The initialization parameters are modified if the application calls"]
    #[doc = "  Reconfigure() function."]
    #[link_name = "\u{1}_ZN9NvEncoder19GetInitializeParamsEP25_NV_ENC_INITIALIZE_PARAMS"]
    pub fn NvEncoder_GetInitializeParams(
        this: *mut NvEncoder,
        pInitializeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    );
}
extern "C" {
    #[doc = "  @brief  This function is used to run motion estimation"]
    #[doc = "  This is used to run motion estimation on a a pair of frames. The"]
    #[doc = "  application must copy the reference frame data to the buffer obtained"]
    #[doc = "  by calling GetNextReferenceFrame(), and copy the input frame data to"]
    #[doc = "  the buffer obtained by calling GetNextInputFrame() before calling the"]
    #[doc = "  RunMotionEstimation() function."]
    #[link_name = "\u{1}_ZN9NvEncoder19RunMotionEstimationERSt6vectorIhSaIhEE"]
    pub fn NvEncoder_RunMotionEstimation(this: *mut NvEncoder, mvData: *mut std_vector);
}
extern "C" {
    #[doc = "  @brief This function is used to get an available reference frame."]
    #[doc = "  Application must call this function to get a pointer to reference buffer,"]
    #[doc = "  to be used in the subsequent RunMotionEstimation() function."]
    #[link_name = "\u{1}_ZN9NvEncoder21GetNextReferenceFrameEv"]
    pub fn NvEncoder_GetNextReferenceFrame(this: *mut NvEncoder) -> *const NvEncInputFrame;
}
extern "C" {
    #[doc = "  @brief This function is used to get sequence and picture parameter headers."]
    #[doc = "  Application can call this function after encoder is initialized to get SPS and PPS"]
    #[doc = "  nalus for the current encoder instance. The sequence header data might change when"]
    #[doc = "  application calls Reconfigure() function."]
    #[link_name = "\u{1}_ZN9NvEncoder17GetSequenceParamsERSt6vectorIhSaIhEE"]
    pub fn NvEncoder_GetSequenceParams(this: *mut NvEncoder, seqParams: *mut std_vector);
}
extern "C" {
    #[doc = "  @brief This a static function to get chroma offsets for YUV planar formats."]
    #[link_name = "\u{1}_ZN9NvEncoder24GetChromaSubPlaneOffsetsE21_NV_ENC_BUFFER_FORMATjjRSt6vectorIjSaIjEE"]
    pub fn NvEncoder_GetChromaSubPlaneOffsets(
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        pitch: u32,
        height: u32,
        chromaOffsets: *mut std_vector,
    );
}
extern "C" {
    #[doc = "  @brief This a static function to get the chroma plane pitch for YUV planar formats."]
    #[link_name = "\u{1}_ZN9NvEncoder14GetChromaPitchE21_NV_ENC_BUFFER_FORMATj"]
    pub fn NvEncoder_GetChromaPitch(bufferFormat: NV_ENC_BUFFER_FORMAT, lumaPitch: u32) -> u32;
}
extern "C" {
    #[doc = "  @brief This a static function to get the number of chroma planes for YUV planar formats."]
    #[link_name = "\u{1}_ZN9NvEncoder18GetNumChromaPlanesE21_NV_ENC_BUFFER_FORMAT"]
    pub fn NvEncoder_GetNumChromaPlanes(bufferFormat: NV_ENC_BUFFER_FORMAT) -> u32;
}
extern "C" {
    #[doc = "  @brief This a static function to get the chroma plane width in bytes for YUV planar formats."]
    #[link_name = "\u{1}_ZN9NvEncoder21GetChromaWidthInBytesE21_NV_ENC_BUFFER_FORMATj"]
    pub fn NvEncoder_GetChromaWidthInBytes(
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        lumaWidth: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "  @brief This a static function to get the chroma planes height in bytes for YUV planar formats."]
    #[link_name = "\u{1}_ZN9NvEncoder15GetChromaHeightE21_NV_ENC_BUFFER_FORMATj"]
    pub fn NvEncoder_GetChromaHeight(bufferFormat: NV_ENC_BUFFER_FORMAT, lumaHeight: u32) -> u32;
}
extern "C" {
    #[doc = "  @brief This a static function to get the width in bytes for the frame."]
    #[doc = "  For YUV planar format this is the width in bytes of the luma plane."]
    #[link_name = "\u{1}_ZN9NvEncoder15GetWidthInBytesE21_NV_ENC_BUFFER_FORMATj"]
    pub fn NvEncoder_GetWidthInBytes(bufferFormat: NV_ENC_BUFFER_FORMAT, width: u32) -> u32;
}
extern "C" {
    #[doc = "  @brief This function is used to register CUDA, D3D or OpenGL input buffers with NvEncodeAPI."]
    #[doc = "  This is non public function and is called by derived class for allocating"]
    #[doc = "  and registering input buffers."]
    #[link_name = "\u{1}_ZN9NvEncoder22RegisterInputResourcesESt6vectorIPvSaIS1_EE27_NV_ENC_INPUT_RESOURCE_TYPEiii21_NV_ENC_BUFFER_FORMATb"]
    pub fn NvEncoder_RegisterInputResources(
        this: *mut NvEncoder,
        inputframes: std_vector,
        eResourceType: NV_ENC_INPUT_RESOURCE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        bReferenceFrame: bool,
    );
}
extern "C" {
    #[doc = "  @brief This function is used to unregister resources which had been previously registered for encoding"]
    #[doc = "         using RegisterInputResources() function."]
    #[link_name = "\u{1}_ZN9NvEncoder24UnregisterInputResourcesEv"]
    pub fn NvEncoder_UnregisterInputResources(this: *mut NvEncoder);
}
extern "C" {
    #[doc = "  @brief This function is used to register CUDA, D3D or OpenGL input or output buffers with NvEncodeAPI."]
    #[link_name = "\u{1}_ZN9NvEncoder16RegisterResourceEPv27_NV_ENC_INPUT_RESOURCE_TYPEiii21_NV_ENC_BUFFER_FORMAT20_NV_ENC_BUFFER_USAGE"]
    pub fn NvEncoder_RegisterResource(
        this: *mut NvEncoder,
        pBuffer: *mut ::std::os::raw::c_void,
        eResourceType: NV_ENC_INPUT_RESOURCE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        bufferUsage: NV_ENC_BUFFER_USAGE,
    ) -> NV_ENC_REGISTERED_PTR;
}
extern "C" {
    #[doc = "  @brief This function is used to submit the encode commands to the"]
    #[doc = "         NVENC hardware."]
    #[link_name = "\u{1}_ZN9NvEncoder8DoEncodeEPvS0_P18_NV_ENC_PIC_PARAMS"]
    pub fn NvEncoder_DoEncode(
        this: *mut NvEncoder,
        inputBuffer: NV_ENC_INPUT_PTR,
        outputBuffer: NV_ENC_OUTPUT_PTR,
        pPicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = "  @brief This function is used to submit the encode commands to the"]
    #[doc = "         NVENC hardware for ME only mode."]
    #[link_name = "\u{1}_ZN9NvEncoder18DoMotionEstimationEPvS0_S0_"]
    pub fn NvEncoder_DoMotionEstimation(
        this: *mut NvEncoder,
        inputBuffer: NV_ENC_INPUT_PTR,
        inputBufferForReference: NV_ENC_INPUT_PTR,
        outputBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = "  @brief This function is used to map the input buffers to NvEncodeAPI."]
    #[link_name = "\u{1}_ZN9NvEncoder12MapResourcesEj"]
    pub fn NvEncoder_MapResources(this: *mut NvEncoder, bfrIdx: u32);
}
extern "C" {
    #[doc = "  @brief This function is used to wait for completion of encode command."]
    #[link_name = "\u{1}_ZN9NvEncoder22WaitForCompletionEventEi"]
    pub fn NvEncoder_WaitForCompletionEvent(this: *mut NvEncoder, iEvent: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  @brief This function is used to send EOS to HW encoder."]
    #[link_name = "\u{1}_ZN9NvEncoder7SendEOSEv"]
    pub fn NvEncoder_SendEOS(this: *mut NvEncoder);
}
extern "C" {
    #[doc = "  @brief  NvEncoder class constructor."]
    #[doc = "  NvEncoder class constructor cannot be called directly by the application."]
    #[link_name = "\u{1}_ZN9NvEncoderC2E19_NV_ENC_DEVICE_TYPEPvjj21_NV_ENC_BUFFER_FORMATjbb"]
    pub fn NvEncoder_NvEncoder(
        this: *mut NvEncoder,
        eDeviceType: NV_ENC_DEVICE_TYPE,
        pDevice: *mut ::std::os::raw::c_void,
        nWidth: u32,
        nHeight: u32,
        eBufferFormat: NV_ENC_BUFFER_FORMAT,
        nOutputDelay: u32,
        bMotionEstimationOnly: bool,
        bOutputInVideoMemory: bool,
    );
}
impl NvEncoder {
    #[inline]
    pub unsafe fn CreateEncoder(&mut self, pEncodeParams: *const NV_ENC_INITIALIZE_PARAMS) {
        NvEncoder_CreateEncoder(self, pEncodeParams)
    }
    #[inline]
    pub unsafe fn DestroyEncoder(&mut self) {
        NvEncoder_DestroyEncoder(self)
    }
    #[inline]
    pub unsafe fn Reconfigure(
        &mut self,
        pReconfigureParams: *const NV_ENC_RECONFIGURE_PARAMS,
    ) -> bool {
        NvEncoder_Reconfigure(self, pReconfigureParams)
    }
    #[inline]
    pub unsafe fn GetNextInputFrame(&mut self) -> *const NvEncInputFrame {
        NvEncoder_GetNextInputFrame(self)
    }
    #[inline]
    pub unsafe fn EncodeFrame(
        &mut self,
        vPacket: *mut std_vector,
        pPicParams: *mut NV_ENC_PIC_PARAMS,
    ) {
        NvEncoder_EncodeFrame(self, vPacket, pPicParams)
    }
    #[inline]
    pub unsafe fn EndEncode(&mut self, vPacket: *mut std_vector) {
        NvEncoder_EndEncode(self, vPacket)
    }
    #[inline]
    pub unsafe fn GetCapabilityValue(
        &mut self,
        guidCodec: GUID,
        capsToQuery: NV_ENC_CAPS,
    ) -> ::std::os::raw::c_int {
        NvEncoder_GetCapabilityValue(self, guidCodec, capsToQuery)
    }
    #[inline]
    pub unsafe fn GetFrameSize(&self) -> ::std::os::raw::c_int {
        NvEncoder_GetFrameSize(self)
    }
    #[inline]
    pub unsafe fn CreateDefaultEncoderParams(
        &mut self,
        pIntializeParams: *mut NV_ENC_INITIALIZE_PARAMS,
        codecGuid: GUID,
        presetGuid: GUID,
    ) {
        NvEncoder_CreateDefaultEncoderParams(self, pIntializeParams, codecGuid, presetGuid)
    }
    #[inline]
    pub unsafe fn GetInitializeParams(&mut self, pInitializeParams: *mut NV_ENC_INITIALIZE_PARAMS) {
        NvEncoder_GetInitializeParams(self, pInitializeParams)
    }
    #[inline]
    pub unsafe fn RunMotionEstimation(&mut self, mvData: *mut std_vector) {
        NvEncoder_RunMotionEstimation(self, mvData)
    }
    #[inline]
    pub unsafe fn GetNextReferenceFrame(&mut self) -> *const NvEncInputFrame {
        NvEncoder_GetNextReferenceFrame(self)
    }
    #[inline]
    pub unsafe fn GetSequenceParams(&mut self, seqParams: *mut std_vector) {
        NvEncoder_GetSequenceParams(self, seqParams)
    }
    #[inline]
    pub unsafe fn GetChromaSubPlaneOffsets(
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        pitch: u32,
        height: u32,
        chromaOffsets: *mut std_vector,
    ) {
        NvEncoder_GetChromaSubPlaneOffsets(bufferFormat, pitch, height, chromaOffsets)
    }
    #[inline]
    pub unsafe fn GetChromaPitch(bufferFormat: NV_ENC_BUFFER_FORMAT, lumaPitch: u32) -> u32 {
        NvEncoder_GetChromaPitch(bufferFormat, lumaPitch)
    }
    #[inline]
    pub unsafe fn GetNumChromaPlanes(bufferFormat: NV_ENC_BUFFER_FORMAT) -> u32 {
        NvEncoder_GetNumChromaPlanes(bufferFormat)
    }
    #[inline]
    pub unsafe fn GetChromaWidthInBytes(bufferFormat: NV_ENC_BUFFER_FORMAT, lumaWidth: u32) -> u32 {
        NvEncoder_GetChromaWidthInBytes(bufferFormat, lumaWidth)
    }
    #[inline]
    pub unsafe fn GetChromaHeight(bufferFormat: NV_ENC_BUFFER_FORMAT, lumaHeight: u32) -> u32 {
        NvEncoder_GetChromaHeight(bufferFormat, lumaHeight)
    }
    #[inline]
    pub unsafe fn GetWidthInBytes(bufferFormat: NV_ENC_BUFFER_FORMAT, width: u32) -> u32 {
        NvEncoder_GetWidthInBytes(bufferFormat, width)
    }
    #[inline]
    pub unsafe fn RegisterInputResources(
        &mut self,
        inputframes: std_vector,
        eResourceType: NV_ENC_INPUT_RESOURCE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        bReferenceFrame: bool,
    ) {
        NvEncoder_RegisterInputResources(
            self,
            inputframes,
            eResourceType,
            width,
            height,
            pitch,
            bufferFormat,
            bReferenceFrame,
        )
    }
    #[inline]
    pub unsafe fn UnregisterInputResources(&mut self) {
        NvEncoder_UnregisterInputResources(self)
    }
    #[inline]
    pub unsafe fn RegisterResource(
        &mut self,
        pBuffer: *mut ::std::os::raw::c_void,
        eResourceType: NV_ENC_INPUT_RESOURCE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bufferFormat: NV_ENC_BUFFER_FORMAT,
        bufferUsage: NV_ENC_BUFFER_USAGE,
    ) -> NV_ENC_REGISTERED_PTR {
        NvEncoder_RegisterResource(
            self,
            pBuffer,
            eResourceType,
            width,
            height,
            pitch,
            bufferFormat,
            bufferUsage,
        )
    }
    #[inline]
    pub unsafe fn DoEncode(
        &mut self,
        inputBuffer: NV_ENC_INPUT_PTR,
        outputBuffer: NV_ENC_OUTPUT_PTR,
        pPicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS {
        NvEncoder_DoEncode(self, inputBuffer, outputBuffer, pPicParams)
    }
    #[inline]
    pub unsafe fn DoMotionEstimation(
        &mut self,
        inputBuffer: NV_ENC_INPUT_PTR,
        inputBufferForReference: NV_ENC_INPUT_PTR,
        outputBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS {
        NvEncoder_DoMotionEstimation(self, inputBuffer, inputBufferForReference, outputBuffer)
    }
    #[inline]
    pub unsafe fn MapResources(&mut self, bfrIdx: u32) {
        NvEncoder_MapResources(self, bfrIdx)
    }
    #[inline]
    pub unsafe fn WaitForCompletionEvent(&mut self, iEvent: ::std::os::raw::c_int) {
        NvEncoder_WaitForCompletionEvent(self, iEvent)
    }
    #[inline]
    pub unsafe fn SendEOS(&mut self) {
        NvEncoder_SendEOS(self)
    }
    #[inline]
    pub unsafe fn new(
        eDeviceType: NV_ENC_DEVICE_TYPE,
        pDevice: *mut ::std::os::raw::c_void,
        nWidth: u32,
        nHeight: u32,
        eBufferFormat: NV_ENC_BUFFER_FORMAT,
        nOutputDelay: u32,
        bMotionEstimationOnly: bool,
        bOutputInVideoMemory: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        NvEncoder_NvEncoder(
            __bindgen_tmp.as_mut_ptr(),
            eDeviceType,
            pDevice,
            nWidth,
            nHeight,
            eBufferFormat,
            nOutputDelay,
            bMotionEstimationOnly,
            bOutputInVideoMemory,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = "  @brief  NvEncoder class virtual destructor."]
    #[link_name = "\u{1}_ZN9NvEncoderD1Ev"]
    pub fn NvEncoder_NvEncoder_destructor(this: *mut NvEncoder);
}
#[doc = "  @brief Encoder for CUDA device memory."]
#[repr(C)]
pub struct NvEncoderCuda {
    pub _base: NvEncoder,
    pub m_cuContext: CUcontext,
    pub m_cudaPitch: size_t,
}
#[test]
fn bindgen_test_layout_NvEncoderCuda() {
    assert_eq!(
        ::std::mem::size_of::<NvEncoderCuda>(),
        8264usize,
        concat!("Size of: ", stringify!(NvEncoderCuda))
    );
    assert_eq!(
        ::std::mem::align_of::<NvEncoderCuda>(),
        8usize,
        concat!("Alignment of ", stringify!(NvEncoderCuda))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoderCuda>())).m_cuContext as *const _ as usize },
        8248usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoderCuda),
            "::",
            stringify!(m_cuContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NvEncoderCuda>())).m_cudaPitch as *const _ as usize },
        8256usize,
        concat!(
            "Offset of field: ",
            stringify!(NvEncoderCuda),
            "::",
            stringify!(m_cudaPitch)
        )
    );
}
extern "C" {
    #[doc = "  @brief This is a static function to copy input data from host memory to device memory."]
    #[doc = "  This function assumes YUV plane is a single contiguous memory segment."]
    #[link_name = "\u{1}_ZN13NvEncoderCuda17CopyToDeviceFrameEP8CUctx_stPvjyjii17CUmemorytype_enum21_NV_ENC_BUFFER_FORMATPKjjbP11CUstream_st"]
    pub fn NvEncoderCuda_CopyToDeviceFrame(
        device: CUcontext,
        pSrcFrame: *mut ::std::os::raw::c_void,
        nSrcPitch: u32,
        pDstFrame: CUdeviceptr,
        dstPitch: u32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        srcMemoryType: CUmemorytype,
        pixelFormat: NV_ENC_BUFFER_FORMAT,
        dstChromaOffsets: *const u32,
        numChromaPlanes: u32,
        bUnAlignedDeviceCopy: bool,
        stream: CUstream,
    );
}
extern "C" {
    #[doc = "  @brief This is a static function to copy input data from host memory to device memory."]
    #[doc = "  Application must pass a seperate device pointer for each YUV plane."]
    #[link_name = "\u{1}_ZN13NvEncoderCuda17CopyToDeviceFrameEP8CUctx_stPvjyjii17CUmemorytype_enum21_NV_ENC_BUFFER_FORMATPyjjb"]
    pub fn NvEncoderCuda_CopyToDeviceFrame1(
        device: CUcontext,
        pSrcFrame: *mut ::std::os::raw::c_void,
        nSrcPitch: u32,
        pDstFrame: CUdeviceptr,
        dstPitch: u32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        srcMemoryType: CUmemorytype,
        pixelFormat: NV_ENC_BUFFER_FORMAT,
        dstChromaPtr: *mut CUdeviceptr,
        dstChromaPitch: u32,
        numChromaPlanes: u32,
        bUnAlignedDeviceCopy: bool,
    );
}
extern "C" {
    #[doc = "  @brief This function sets input and output CUDA streams"]
    #[link_name = "\u{1}_ZN13NvEncoderCuda16SetIOCudaStreamsEPvS0_"]
    pub fn NvEncoderCuda_SetIOCudaStreams(
        this: *mut NvEncoderCuda,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13NvEncoderCudaC1EP8CUctx_stjj21_NV_ENC_BUFFER_FORMATjbb"]
    pub fn NvEncoderCuda_NvEncoderCuda(
        this: *mut NvEncoderCuda,
        cuContext: CUcontext,
        nWidth: u32,
        nHeight: u32,
        eBufferFormat: NV_ENC_BUFFER_FORMAT,
        nExtraOutputDelay: u32,
        bMotionEstimationOnly: bool,
        bOPInVideoMemory: bool,
    );
}
impl NvEncoderCuda {
    #[inline]
    pub unsafe fn CopyToDeviceFrame(
        device: CUcontext,
        pSrcFrame: *mut ::std::os::raw::c_void,
        nSrcPitch: u32,
        pDstFrame: CUdeviceptr,
        dstPitch: u32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        srcMemoryType: CUmemorytype,
        pixelFormat: NV_ENC_BUFFER_FORMAT,
        dstChromaOffsets: *const u32,
        numChromaPlanes: u32,
        bUnAlignedDeviceCopy: bool,
        stream: CUstream,
    ) {
        NvEncoderCuda_CopyToDeviceFrame(
            device,
            pSrcFrame,
            nSrcPitch,
            pDstFrame,
            dstPitch,
            width,
            height,
            srcMemoryType,
            pixelFormat,
            dstChromaOffsets,
            numChromaPlanes,
            bUnAlignedDeviceCopy,
            stream,
        )
    }
    #[inline]
    pub unsafe fn CopyToDeviceFrame1(
        device: CUcontext,
        pSrcFrame: *mut ::std::os::raw::c_void,
        nSrcPitch: u32,
        pDstFrame: CUdeviceptr,
        dstPitch: u32,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        srcMemoryType: CUmemorytype,
        pixelFormat: NV_ENC_BUFFER_FORMAT,
        dstChromaPtr: *mut CUdeviceptr,
        dstChromaPitch: u32,
        numChromaPlanes: u32,
        bUnAlignedDeviceCopy: bool,
    ) {
        NvEncoderCuda_CopyToDeviceFrame1(
            device,
            pSrcFrame,
            nSrcPitch,
            pDstFrame,
            dstPitch,
            width,
            height,
            srcMemoryType,
            pixelFormat,
            dstChromaPtr,
            dstChromaPitch,
            numChromaPlanes,
            bUnAlignedDeviceCopy,
        )
    }
    #[inline]
    pub unsafe fn SetIOCudaStreams(
        &mut self,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) {
        NvEncoderCuda_SetIOCudaStreams(self, inputStream, outputStream)
    }
    #[inline]
    pub unsafe fn new(
        cuContext: CUcontext,
        nWidth: u32,
        nHeight: u32,
        eBufferFormat: NV_ENC_BUFFER_FORMAT,
        nExtraOutputDelay: u32,
        bMotionEstimationOnly: bool,
        bOPInVideoMemory: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        NvEncoderCuda_NvEncoderCuda(
            __bindgen_tmp.as_mut_ptr(),
            cuContext,
            nWidth,
            nHeight,
            eBufferFormat,
            nExtraOutputDelay,
            bMotionEstimationOnly,
            bOPInVideoMemory,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN13NvEncoderCudaD1Ev"]
    pub fn NvEncoderCuda_NvEncoderCuda_destructor(this: *mut NvEncoderCuda);
}
extern "C" {
    #[doc = "  @brief This function is used to release the input buffers allocated for encoding."]
    #[doc = "  This function is an override of virtual function NvEncoder::ReleaseInputBuffers()."]
    #[link_name = "\u{1}_ZN13NvEncoderCuda19ReleaseInputBuffersEv"]
    pub fn NvEncoderCuda_ReleaseInputBuffers(this: *mut ::std::os::raw::c_void);
}
#[test]
fn __bindgen_test_layout_std_vector_open0_ptr_void_std_allocator_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NvEncInputFrame_std_allocator_open1_NvEncInputFrame_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_NvEncInputFrame_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_REGISTERED_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NvEncInputFrame_std_allocator_open1_NvEncInputFrame_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_NvEncInputFrame_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_REGISTERED_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_INPUT_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_INPUT_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_ptr_void_std_allocator_open1_ptr_void_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_OUTPUT_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NV_ENC_OUTPUT_PTR_std_allocator_open1_ptr_void_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_ptr_void_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
